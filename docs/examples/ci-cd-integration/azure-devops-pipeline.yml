# Azure DevOps Pipeline for TypoSentinel Security Scanning
# This pipeline provides comprehensive security scanning with TypoSentinel
# across different environments and project types.

trigger:
  branches:
    include:
      - main
      - develop
      - release/*
  paths:
    exclude:
      - docs/*
      - README.md
      - .gitignore

pr:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - docs/*
      - README.md

schedules:
  - cron: "0 2 * * *"
    displayName: Daily security scan
    branches:
      include:
        - main
    always: true

parameters:
  - name: scanType
    displayName: 'Scan Type'
    type: string
    default: 'comprehensive'
    values:
      - quick
      - comprehensive
      - enterprise
  - name: projectType
    displayName: 'Project Type'
    type: string
    default: 'auto-detect'
    values:
      - auto-detect
      - nodejs
      - go
      - python
      - java
      - generic
  - name: failOnHigh
    displayName: 'Fail on High Severity'
    type: boolean
    default: true
  - name: notifySecurity
    displayName: 'Notify Security Team'
    type: boolean
    default: false

variables:
  - name: typosentinelVersion
    value: 'latest'
  - name: scanTimeout
    value: '600'
  - name: cacheVersion
    value: 'v1'
  - group: security-notifications  # Variable group for notification settings

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: DetectProject
    displayName: 'üîç Project Detection'
    jobs:
      - job: DetectProjectType
        displayName: 'Detect Project Type'
        steps:
          - checkout: self
            fetchDepth: 1
            
          - task: PowerShell@2
            displayName: 'Detect project type and configuration'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "üîç Detecting project type..."
                
                $projectType = "${{ parameters.projectType }}"
                $scanArgs = ""
                $excludePatterns = @()
                
                if ($projectType -eq "auto-detect") {
                    if (Test-Path "package.json") {
                        $projectType = "nodejs"
                        $excludePatterns = @("node_modules/", "dist/", "build/")
                        Write-Host "‚úÖ Node.js project detected"
                    }
                    elseif (Test-Path "go.mod") {
                        $projectType = "go"
                        $excludePatterns = @("vendor/", "bin/")
                        Write-Host "‚úÖ Go project detected"
                    }
                    elseif ((Test-Path "requirements.txt") -or (Test-Path "pyproject.toml") -or (Test-Path "setup.py")) {
                        $projectType = "python"
                        $excludePatterns = @("__pycache__/", "venv/", ".venv/", "dist/", "build/")
                        Write-Host "‚úÖ Python project detected"
                    }
                    elseif ((Test-Path "pom.xml") -or (Test-Path "build.gradle") -or (Test-Path "build.gradle.kts")) {
                        $projectType = "java"
                        $excludePatterns = @("target/", "build/", ".gradle/")
                        Write-Host "‚úÖ Java project detected"
                    }
                    elseif (Test-Path "Cargo.toml") {
                        $projectType = "rust"
                        $excludePatterns = @("target/", "Cargo.lock")
                        Write-Host "‚úÖ Rust project detected"
                    }
                    elseif (Test-Path "composer.json") {
                        $projectType = "php"
                        $excludePatterns = @("vendor/", "cache/")
                        Write-Host "‚úÖ PHP project detected"
                    }
                    else {
                        $projectType = "generic"
                        $excludePatterns = @(".git/", "node_modules/", "vendor/")
                        Write-Host "‚ö†Ô∏è Unknown project type, using generic scanning"
                    }
                }
                
                # Set scan arguments
                if ($projectType -ne "generic") {
                    $scanArgs = "--project-type $projectType"
                }
                
                # Output variables for next stages
                Write-Host "##vso[task.setvariable variable=detectedProjectType;isOutput=true]$projectType"
                Write-Host "##vso[task.setvariable variable=scanArgs;isOutput=true]$scanArgs"
                Write-Host "##vso[task.setvariable variable=excludePatterns;isOutput=true]$($excludePatterns -join ',')"
                
                Write-Host "üìä Project Type: $projectType"
                Write-Host "üîß Scan Args: $scanArgs"
                Write-Host "üö´ Exclude Patterns: $($excludePatterns -join ', ')"
            name: 'projectDetection'

  - stage: SecurityScan
    displayName: 'üõ°Ô∏è Security Scanning'
    dependsOn: DetectProject
    variables:
      detectedProjectType: $[ stageDependencies.DetectProject.DetectProjectType.outputs['projectDetection.detectedProjectType'] ]
      scanArgs: $[ stageDependencies.DetectProject.DetectProjectType.outputs['projectDetection.scanArgs'] ]
      excludePatterns: $[ stageDependencies.DetectProject.DetectProjectType.outputs['projectDetection.excludePatterns'] ]
    jobs:
      - job: QuickScan
        displayName: '‚ö° Quick Security Scan'
        condition: eq(variables['Build.Reason'], 'PullRequest')
        steps:
          - checkout: self
            fetchDepth: 1
            
          - task: Cache@2
            displayName: 'Cache TypoSentinel'
            inputs:
              key: 'typosentinel | $(cacheVersion) | $(Agent.OS) | $(typosentinelVersion)'
              path: '$(Pipeline.Workspace)/.typosentinel'
              restoreKeys: |
                typosentinel | $(cacheVersion) | $(Agent.OS)
                typosentinel | $(cacheVersion)
            
          - task: Bash@3
            displayName: 'Download and install TypoSentinel'
            inputs:
              targetType: 'inline'
              script: |
                echo "üì• Downloading TypoSentinel..."
                mkdir -p $(Pipeline.Workspace)/.typosentinel
                
                # Determine architecture
                ARCH=$(uname -m)
                if [ "$ARCH" = "x86_64" ]; then
                  ARCH="amd64"
                elif [ "$ARCH" = "aarch64" ]; then
                  ARCH="arm64"
                fi
                
                # Download if not cached
                if [ ! -f "$(Pipeline.Workspace)/.typosentinel/typosentinel" ]; then
                  curl -L "https://github.com/typosentinel/typosentinel/releases/latest/download/typosentinel-linux-${ARCH}" \
                       -o "$(Pipeline.Workspace)/.typosentinel/typosentinel"
                  chmod +x "$(Pipeline.Workspace)/.typosentinel/typosentinel"
                fi
                
                # Verify installation
                $(Pipeline.Workspace)/.typosentinel/typosentinel version
                
                # Set path for subsequent tasks
                echo "##vso[task.setvariable variable=TYPOSENTINEL_PATH]$(Pipeline.Workspace)/.typosentinel/typosentinel"
            
          - task: Bash@3
            displayName: 'Run quick security scan'
            inputs:
              targetType: 'inline'
              script: |
                echo "üöÄ Starting quick security scan..."
                
                # Build scan command
                SCAN_CMD="$(TYPOSENTINEL_PATH) scan --preset quick"
                
                if [ -n "$(scanArgs)" ]; then
                  SCAN_CMD="$SCAN_CMD $(scanArgs)"
                fi
                
                if [ -n "$(excludePatterns)" ]; then
                  IFS=',' read -ra EXCLUDES <<< "$(excludePatterns)"
                  for exclude in "${EXCLUDES[@]}"; do
                    SCAN_CMD="$SCAN_CMD --exclude $exclude"
                  done
                fi
                
                # Add output options
                SCAN_CMD="$SCAN_CMD --output json --output-file quick-scan-results.json"
                SCAN_CMD="$SCAN_CMD --output sarif --output-file quick-scan.sarif"
                SCAN_CMD="$SCAN_CMD --timeout 180s --concurrency 4"
                
                echo "üîß Running: $SCAN_CMD"
                
                # Execute scan
                eval $SCAN_CMD || SCAN_EXIT_CODE=$?
                
                # Process results
                if [ -f "quick-scan-results.json" ]; then
                  echo "üìä Scan completed successfully"
                  
                  # Extract metrics
                  TOTAL_PACKAGES=$(jq -r '.summary.total_packages // 0' quick-scan-results.json)
                  THREATS_FOUND=$(jq -r '.summary.threats_found // 0' quick-scan-results.json)
                  HIGH_SEVERITY=$(jq -r '.summary.severity_breakdown.high // 0' quick-scan-results.json)
                  CRITICAL_SEVERITY=$(jq -r '.summary.severity_breakdown.critical // 0' quick-scan-results.json)
                  
                  echo "##vso[task.setvariable variable=totalPackages]$TOTAL_PACKAGES"
                  echo "##vso[task.setvariable variable=threatsFound]$THREATS_FOUND"
                  echo "##vso[task.setvariable variable=highSeverity]$HIGH_SEVERITY"
                  echo "##vso[task.setvariable variable=criticalSeverity]$CRITICAL_SEVERITY"
                  
                  echo "üì¶ Total packages scanned: $TOTAL_PACKAGES"
                  echo "‚ö†Ô∏è Threats found: $THREATS_FOUND"
                  echo "üî¥ High severity: $HIGH_SEVERITY"
                  echo "üíÄ Critical severity: $CRITICAL_SEVERITY"
                  
                  # Set scan status
                  if [ "$CRITICAL_SEVERITY" -gt 0 ] || [ "$HIGH_SEVERITY" -gt 0 ]; then
                    echo "##vso[task.setvariable variable=scanStatus]failed"
                    echo "‚ùå Scan failed due to high/critical severity threats"
                  else
                    echo "##vso[task.setvariable variable=scanStatus]passed"
                    echo "‚úÖ Scan passed"
                  fi
                else
                  echo "‚ùå Scan failed or no results generated"
                  echo "##vso[task.setvariable variable=scanStatus]error"
                  exit ${SCAN_EXIT_CODE:-1}
                fi
            
          - task: PublishTestResults@2
            displayName: 'Publish SARIF results'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: 'quick-scan.sarif'
              testRunTitle: 'TypoSentinel Quick Scan'
              failTaskOnFailedTests: false
            
          - task: PublishBuildArtifacts@1
            displayName: 'Publish scan artifacts'
            condition: always()
            inputs:
              pathToPublish: '$(System.DefaultWorkingDirectory)'
              artifactName: 'quick-scan-results'
              includeRootFolder: false
              
          - task: PowerShell@2
            displayName: 'Comment on Pull Request'
            condition: and(always(), eq(variables['Build.Reason'], 'PullRequest'))
            inputs:
              targetType: 'inline'
              script: |
                $headers = @{
                    'Authorization' = "Bearer $(System.AccessToken)"
                    'Content-Type' = 'application/json'
                }
                
                $comment = @"
## üõ°Ô∏è TypoSentinel Security Scan Results

**Scan Type:** Quick Scan (PR)  
**Project Type:** $(detectedProjectType)  
**Commit:** $(Build.SourceVersion.Substring(0,7))

### üìä Summary
- **Total Packages:** $(totalPackages)
- **Threats Found:** $(threatsFound)
- **Critical:** $(criticalSeverity)
- **High:** $(highSeverity)

"@
                
                if ([int]$(threatsFound) -gt 0) {
                    if ([int]$(criticalSeverity) -gt 0 -or [int]$(highSeverity) -gt 0) {
                        $comment += "‚ùå **Action Required:** Please review and address the security issues before merging.`n"
                    } else {
                        $comment += "‚ö†Ô∏è **Review Recommended:** Consider addressing the identified security issues.`n"
                    }
                } else {
                    $comment += "‚úÖ **No security threats detected!**`n"
                }
                
                $comment += "`n**üìä Full Report:** Check the build artifacts for detailed results."
                
                $body = @{
                    text = $comment
                    status = 1
                } | ConvertTo-Json
                
                $uri = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_apis/git/repositories/$(Build.Repository.ID)/pullRequests/$(System.PullRequest.PullRequestId)/threads?api-version=6.0"
                
                try {
                    Invoke-RestMethod -Uri $uri -Method Post -Body $body -Headers $headers
                    Write-Host "‚úÖ PR comment posted successfully"
                } catch {
                    Write-Host "‚ö†Ô∏è Failed to post PR comment: $($_.Exception.Message)"
                }
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
              
          - task: Bash@3
            displayName: 'Fail on critical/high threats'
            condition: eq(variables['scanStatus'], 'failed')
            inputs:
              targetType: 'inline'
              script: |
                echo "‚ùå Pipeline failed due to critical or high severity security threats"
                echo "üîß Please review and address the security issues before merging"
                exit 1

      - job: ComprehensiveScan
        displayName: 'üîç Comprehensive Security Scan'
        condition: or(eq(variables['Build.Reason'], 'IndividualCI'), eq(variables['Build.Reason'], 'Schedule'), eq(variables['Build.Reason'], 'Manual'))
        steps:
          - checkout: self
            fetchDepth: 1
            
          - task: Cache@2
            displayName: 'Cache TypoSentinel'
            inputs:
              key: 'typosentinel | $(cacheVersion) | $(Agent.OS) | $(typosentinelVersion)'
              path: '$(Pipeline.Workspace)/.typosentinel'
              
          - task: Bash@3
            displayName: 'Download and install TypoSentinel'
            inputs:
              targetType: 'inline'
              script: |
                echo "üì• Downloading TypoSentinel..."
                mkdir -p $(Pipeline.Workspace)/.typosentinel
                
                ARCH=$(uname -m)
                if [ "$ARCH" = "x86_64" ]; then
                  ARCH="amd64"
                elif [ "$ARCH" = "aarch64" ]; then
                  ARCH="arm64"
                fi
                
                if [ ! -f "$(Pipeline.Workspace)/.typosentinel/typosentinel" ]; then
                  curl -L "https://github.com/typosentinel/typosentinel/releases/latest/download/typosentinel-linux-${ARCH}" \
                       -o "$(Pipeline.Workspace)/.typosentinel/typosentinel"
                  chmod +x "$(Pipeline.Workspace)/.typosentinel/typosentinel"
                fi
                
                $(Pipeline.Workspace)/.typosentinel/typosentinel version
                echo "##vso[task.setvariable variable=TYPOSENTINEL_PATH]$(Pipeline.Workspace)/.typosentinel/typosentinel"
                
          - task: Bash@3
            displayName: 'Run comprehensive security scan'
            inputs:
              targetType: 'inline'
              script: |
                echo "üîç Starting comprehensive security scan..."
                
                # Determine scan preset
                if [ "${{ parameters.scanType }}" = "enterprise" ]; then
                  PRESET="enterprise"
                else
                  PRESET="thorough"
                fi
                
                # Build scan command
                SCAN_CMD="$(TYPOSENTINEL_PATH) scan --preset $PRESET"
                
                if [ -n "$(scanArgs)" ]; then
                  SCAN_CMD="$SCAN_CMD $(scanArgs)"
                fi
                
                if [ -n "$(excludePatterns)" ]; then
                  IFS=',' read -ra EXCLUDES <<< "$(excludePatterns)"
                  for exclude in "${EXCLUDES[@]}"; do
                    SCAN_CMD="$SCAN_CMD --exclude $exclude"
                  done
                fi
                
                # Add comprehensive scan options
                SCAN_CMD="$SCAN_CMD --output json --output-file comprehensive-scan-results.json"
                SCAN_CMD="$SCAN_CMD --output sarif --output-file comprehensive-scan.sarif"
                SCAN_CMD="$SCAN_CMD --output table --output-file scan-report.txt"
                SCAN_CMD="$SCAN_CMD --timeout $(scanTimeout)s --concurrency 6"
                SCAN_CMD="$SCAN_CMD --include-metadata --verbose"
                
                echo "üîß Running: $SCAN_CMD"
                
                # Execute scan
                eval $SCAN_CMD
                
                # Process results
                if [ -f "comprehensive-scan-results.json" ]; then
                  TOTAL_PACKAGES=$(jq -r '.summary.total_packages // 0' comprehensive-scan-results.json)
                  THREATS_FOUND=$(jq -r '.summary.threats_found // 0' comprehensive-scan-results.json)
                  CRITICAL=$(jq -r '.summary.severity_breakdown.critical // 0' comprehensive-scan-results.json)
                  HIGH=$(jq -r '.summary.severity_breakdown.high // 0' comprehensive-scan-results.json)
                  
                  echo "##vso[task.setvariable variable=totalPackages]$TOTAL_PACKAGES"
                  echo "##vso[task.setvariable variable=threatsFound]$THREATS_FOUND"
                  echo "##vso[task.setvariable variable=criticalSeverity]$CRITICAL"
                  echo "##vso[task.setvariable variable=highSeverity]$HIGH"
                  
                  echo "üìä Comprehensive scan completed"
                  echo "üì¶ Total packages: $TOTAL_PACKAGES"
                  echo "‚ö†Ô∏è Threats found: $THREATS_FOUND"
                  echo "üî¥ Critical: $CRITICAL"
                  echo "üü† High: $HIGH"
                else
                  echo "‚ùå Scan failed"
                  exit 1
                fi
                
          - task: Bash@3
            displayName: 'Generate security report'
            inputs:
              targetType: 'inline'
              script: |
                echo "üìä Generating security report..."
                
                cat > security-report.md << EOF
                # üõ°Ô∏è TypoSentinel Comprehensive Security Report
                
                **Repository:** $(Build.Repository.Name)  
                **Branch:** $(Build.SourceBranchName)  
                **Commit:** $(Build.SourceVersion)  
                **Project Type:** $(detectedProjectType)  
                **Scan Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")  
                **Pipeline:** $(Build.DefinitionName) #$(Build.BuildNumber)
                
                ## üìä Executive Summary
                EOF
                
                if [ -f "comprehensive-scan-results.json" ]; then
                  TOTAL=$(jq -r '.summary.total_packages // 0' comprehensive-scan-results.json)
                  THREATS=$(jq -r '.summary.threats_found // 0' comprehensive-scan-results.json)
                  DURATION=$(jq -r '.metadata.duration // "N/A"' comprehensive-scan-results.json)
                  VERSION=$(jq -r '.metadata.version // "N/A"' comprehensive-scan-results.json)
                  
                  cat >> security-report.md << EOF
                - **Total Packages Scanned:** $TOTAL
                - **Security Threats Found:** $THREATS
                - **Scan Duration:** $DURATION
                - **Scanner Version:** $VERSION
                
                ## üéØ Severity Breakdown
                | Severity | Count |
                |----------|-------|
                | Critical | $(jq -r '.summary.severity_breakdown.critical // 0' comprehensive-scan-results.json) |
                | High     | $(jq -r '.summary.severity_breakdown.high // 0' comprehensive-scan-results.json) |
                | Medium   | $(jq -r '.summary.severity_breakdown.medium // 0' comprehensive-scan-results.json) |
                | Low      | $(jq -r '.summary.severity_breakdown.low // 0' comprehensive-scan-results.json) |
                
                EOF
                  
                  # Add detailed threat analysis
                  if [ "$THREATS" -gt 0 ]; then
                    echo "## üö® Detailed Threat Analysis" >> security-report.md
                    jq -r '.threats[] | "### \(.package_name) (\(.version // "unknown"))\n- **Severity:** \(.severity)\n- **Confidence:** \(.confidence)\n- **Description:** \(.description)\n- **Recommendation:** \(.recommendation // "Review package authenticity")\n"' comprehensive-scan-results.json >> security-report.md
                  fi
                fi
                
          - task: PublishTestResults@2
            displayName: 'Publish SARIF results'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: 'comprehensive-scan.sarif'
              testRunTitle: 'TypoSentinel Comprehensive Scan'
              
          - task: PublishBuildArtifacts@1
            displayName: 'Publish scan artifacts'
            condition: always()
            inputs:
              pathToPublish: '$(System.DefaultWorkingDirectory)'
              artifactName: 'comprehensive-scan-results'
              
          - task: PowerShell@2
            displayName: 'Create work item for critical findings'
            condition: gt(variables['criticalSeverity'], 0)
            inputs:
              targetType: 'inline'
              script: |
                $headers = @{
                    'Authorization' = "Bearer $(System.AccessToken)"
                    'Content-Type' = 'application/json'
                }
                
                $workItemData = @{
                    op = "add"
                    path = "/fields/System.Title"
                    value = "üö® Critical Security Threats Detected - $(criticalSeverity) Critical, $(highSeverity) High"
                } , @{
                    op = "add"
                    path = "/fields/System.Description"
                    value = @"
                ## üõ°Ô∏è TypoSentinel Security Alert
                
                **Critical security threats have been detected in this repository.**
                
                ### üìä Summary
                - **Critical Threats:** $(criticalSeverity)
                - **High Threats:** $(highSeverity)
                - **Scan Date:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
                - **Commit:** $(Build.SourceVersion)
                - **Pipeline Run:** $(Build.BuildUri)
                
                ### üîß Next Steps
                1. Review the detailed scan results in the pipeline artifacts
                2. Address critical and high severity threats immediately
                3. Update dependencies and packages as needed
                4. Re-run the security scan to verify fixes
                
                ### üìã Resources
                - [Pipeline Results]($(Build.BuildUri))
                - [TypoSentinel Documentation](https://github.com/typosentinel/typosentinel)
                
                ---
                *This work item was automatically created by TypoSentinel security scanning.*
"@
                } , @{
                    op = "add"
                    path = "/fields/System.WorkItemType"
                    value = "Bug"
                } , @{
                    op = "add"
                    path = "/fields/Microsoft.VSTS.Common.Priority"
                    value = 1
                } , @{
                    op = "add"
                    path = "/fields/Microsoft.VSTS.Common.Severity"
                    value = "1 - Critical"
                } , @{
                    op = "add"
                    path = "/fields/System.Tags"
                    value = "security;critical;typosentinel"
                }
                
                $body = $workItemData | ConvertTo-Json -Depth 3
                $uri = "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_apis/wit/workitems/`$Bug?api-version=6.0"
                
                try {
                    $result = Invoke-RestMethod -Uri $uri -Method Post -Body $body -Headers $headers
                    Write-Host "‚úÖ Work item created: $($result.id)"
                } catch {
                    Write-Host "‚ö†Ô∏è Failed to create work item: $($_.Exception.Message)"
                }
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

  - stage: Notifications
    displayName: 'üì¢ Security Notifications'
    dependsOn: SecurityScan
    condition: and(always(), gt(dependencies.SecurityScan.outputs['ComprehensiveScan.criticalSeverity'], 0))
    jobs:
      - job: NotifySecurityTeam
        displayName: 'Notify Security Team'
        steps:
          - task: PowerShell@2
            displayName: 'Send email notification'
            inputs:
              targetType: 'inline'
              script: |
                # Email notification logic would go here
                # This would typically integrate with your organization's email system
                Write-Host "üìß Sending security notification email..."
                Write-Host "Critical threats detected: $(criticalSeverity)"
                Write-Host "High threats detected: $(highSeverity)"
                
          - task: PowerShell@2
            displayName: 'Send Slack notification'
            condition: and(eq('${{ parameters.notifySecurity }}', true), ne(variables['slackWebhook'], ''))
            inputs:
              targetType: 'inline'
              script: |
                $slackMessage = @{
                    text = "üö® TypoSentinel Security Alert"
                    attachments = @(
                        @{
                            color = "danger"
                            title = "Critical Security Threats Detected"
                            fields = @(
                                @{
                                    title = "Repository"
                                    value = "$(Build.Repository.Name)"
                                    short = $true
                                },
                                @{
                                    title = "Branch"
                                    value = "$(Build.SourceBranchName)"
                                    short = $true
                                },
                                @{
                                    title = "Critical Threats"
                                    value = "$(criticalSeverity)"
                                    short = $true
                                },
                                @{
                                    title = "High Threats"
                                    value = "$(highSeverity)"
                                    short = $true
                                }
                            )
                            actions = @(
                                @{
                                    type = "button"
                                    text = "View Pipeline"
                                    url = "$(Build.BuildUri)"
                                }
                            )
                        }
                    )
                } | ConvertTo-Json -Depth 5
                
                try {
                    Invoke-RestMethod -Uri "$(slackWebhook)" -Method Post -Body $slackMessage -ContentType 'application/json'
                    Write-Host "‚úÖ Slack notification sent successfully"
                } catch {
                    Write-Host "‚ö†Ô∏è Failed to send Slack notification: $($_.Exception.Message)"
                }