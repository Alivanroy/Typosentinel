To add an SBOM (Software Bill of Materials) capability to **Typosentinel**, you’d basically need to integrate a module that:

1. **Generates** SBOMs for scanned packages (both source and release artifacts) in standard formats like **CycloneDX** or **SPDX**.
2. **Correlates** SBOM entries with the results from Typosentinel’s typo-squatting / backdoor detection.
3. **Exports** the combined result for downstream consumption in CI/CD, vulnerability scanners, or audit reports.

Here’s a practical way to implement it:

---

## **1. Choose an SBOM Format**

* **CycloneDX** (JSON or XML) → well-supported by OWASP Dependency-Track, GitHub, etc.
* **SPDX** (JSON, Tag/Value) → common in Linux Foundation projects.
* Recommendation: **Use CycloneDX JSON** first — cleaner integration with security dashboards.

---

## **2. Decide on SBOM Generation Point**

For Typosentinel, you can hook SBOM generation into:

* **After dependency enumeration** (when Typosentinel lists packages from `requirements.txt`, `package.json`, `go.mod`, etc.)
* **After artifact scan** (for binary releases like `.whl`, `.tar.gz`, `.tgz`).

---

## **3. Use Existing SBOM Libraries**

Instead of reinventing the wheel:

* **Python**: [`cyclonedx-python-lib`](https://github.com/CycloneDX/cyclonedx-python-lib)
* **Go**: [`spdx-tools`](https://github.com/spdx/tools-golang)
* **Multi-language**: [`syft`](https://github.com/anchore/syft) — can scan containers, repos, and directories.

Example in Python:

```python
from cyclonedx.model.bom import Bom
from cyclonedx.model.component import Component, ComponentType
from cyclonedx.output import get_instance, OutputFormat

def generate_sbom(packages):
    bom = Bom()
    for pkg in packages:
        bom.components.add(
            Component(
                name=pkg.name,
                version=pkg.version,
                type=ComponentType.LIBRARY,
                purl=f"pkg:pypi/{pkg.name}@{pkg.version}"
            )
        )
    outputter = get_instance(bom, OutputFormat.JSON)
    return outputter.output_as_string()
```

Here `packages` can come directly from Typosentinel’s dependency resolution step.

---

## **4. Enrich SBOM with Typosentinel Metadata**

Add **custom properties** or **notes** for:

* Detection flags (typosquat, suspicious commit, XZ-style anomaly, etc.)
* Risk scores
* Artifact–source diff summaries

CycloneDX supports [properties](https://cyclonedx.org/docs/1.4/json/#components_items_properties_items) for this:

```json
"properties": [
    {
        "name": "typosentinel:score",
        "value": "0.92"
    },
    {
        "name": "typosentinel:alert",
        "value": "Possible typosquat"
    }
]
```

---

## **5. Integrate into CLI / API**

Example CLI extension:

```bash
typosentinel scan ./repo --sbom-format cyclonedx --sbom-output sbom.json
```

* `--sbom-format`: `cyclonedx` | `spdx`
* `--sbom-output`: Path to store SBOM

---

## **6. CI/CD Usage**

* Generate SBOM **per build**.
* Push SBOM to **Dependency-Track**, **GitHub Advanced Security**, or internal dashboards.
* Automate **alerting** if a component in the SBOM is flagged by Typosentinel or by external vuln feeds.

---

If you want, I can **write you the full `/sbom` module** for Typosentinel, with:

* A Python generator that consumes Typosentinel’s scan results.
* Optional **Go wrapper** so it’s compatible with your Go CLI structure.
* Output in both **CycloneDX** and **SPDX** formats.

I can also make it **auto-merge detection results into the SBOM**, so you have one combined file for security teams instead of two separate reports.

Do you want me to prepare that module? That way SBOM support would be built directly into Typosentinel’s core.
