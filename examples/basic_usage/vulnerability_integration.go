package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/Alivanroy/Typosentinel/internal/vulnerability"
	"github.com/Alivanroy/Typosentinel/pkg/types"
)

// Example demonstrating how to integrate and use the open-source vulnerability databases
func mainVulnerabilityExample() {
	// Example 1: Using individual databases
	fmt.Println("=== Example 1: Individual Database Usage ===")
	useIndividualDatabases()

	// Example 2: Using the vulnerability manager with multiple databases
	fmt.Println("\n=== Example 2: Vulnerability Manager Usage ===")
	useVulnerabilityManager()

	// Example 3: Configuration-driven setup
	fmt.Println("\n=== Example 3: Configuration-driven Setup ===")
	useConfigurationDrivenSetup()
}

// useIndividualDatabases demonstrates using each database individually
func useIndividualDatabases() {
	// Create a test package
	testPackage := &types.Package{
		Name:     "lodash",
		Version:  "4.17.20",
		Registry: "npm",
	}

	// 1. OSV Database
	fmt.Println("\n--- OSV Database ---")
	osvDB := vulnerability.NewOSVDatabase()
	osvVulns, err := osvDB.CheckVulnerabilities(testPackage)
	if err != nil {
		log.Printf("OSV error: %v", err)
	} else {
		fmt.Printf("OSV found %d vulnerabilities\n", len(osvVulns))
		for _, vuln := range osvVulns {
			fmt.Printf("  - %s: %s (Severity: %s)\n", vuln.ID, vuln.Title, vuln.Severity)
		}
	}

	// 2. GitHub Advisory Database
	fmt.Println("\n--- GitHub Advisory Database ---")
	githubDB := vulnerability.NewGitHubAdvisoryDatabase("") // No token for demo
	githubVulns, err := githubDB.CheckVulnerabilities(testPackage)
	if err != nil {
		log.Printf("GitHub error: %v", err)
	} else {
		fmt.Printf("GitHub found %d vulnerabilities\n", len(githubVulns))
		for _, vuln := range githubVulns {
			fmt.Printf("  - %s: %s (Severity: %s)\n", vuln.ID, vuln.Title, vuln.Severity)
		}
	}

	// 3. NVD Database (existing)
	fmt.Println("\n--- NVD Database ---")
	nvdDB := vulnerability.NewCVEDatabase() // No API key needed
	nvdVulns, err := nvdDB.CheckVulnerabilities(testPackage)
	if err != nil {
		log.Printf("NVD error: %v", err)
	} else {
		fmt.Printf("NVD found %d vulnerabilities\n", len(nvdVulns))
		for _, vuln := range nvdVulns {
			fmt.Printf("  - %s: %s (Severity: %s)\n", vuln.ID, vuln.Title, vuln.Severity)
		}
	}
}

// useVulnerabilityManager demonstrates using the vulnerability manager
func useVulnerabilityManager() {
	// Create manager configuration
	config := &vulnerability.ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
				Timeout: 15 * time.Second,
			},
			{
				Type:    "github",
				Enabled: true,
				Timeout: 20 * time.Second,
				// APIKey: "your_github_token_here", // Uncomment and add your token
			},
			{
				Type:    "nvd",
				Enabled: true,
				Timeout: 25 * time.Second,
				// APIKey: "your_nvd_api_key_here", // Uncomment and add your API key
			},
		},
		ParallelQueries: true,
		Timeout:         30 * time.Second,
		MergeResults:    true,
		DeduplicateByID: true,
		Priority:        []string{"osv", "github", "nvd"},
	}

	// Create vulnerability manager
	manager := vulnerability.NewManager(config)

	// Test packages with known vulnerabilities
	testPackages := []*types.Package{
		{
			Name:     "lodash",
			Version:  "4.17.20",
			Registry: "npm",
		},
		{
			Name:     "express",
			Version:  "4.17.1",
			Registry: "npm",
		},
		{
			Name:     "django",
			Version:  "3.1.0",
			Registry: "pypi",
		},
	}

	fmt.Printf("Configured databases: %v\n", manager.GetDatabaseNames())
	fmt.Printf("Database count: %d\n", manager.GetDatabaseCount())

	for _, pkg := range testPackages {
		fmt.Printf("\n--- Checking %s@%s (%s) ---\n", pkg.Name, pkg.Version, pkg.Registry)

		start := time.Now()
		vulns, err := manager.CheckVulnerabilities(pkg)
		duration := time.Since(start)

		if err != nil {
			log.Printf("Error checking vulnerabilities: %v", err)
			continue
		}

		fmt.Printf("Found %d vulnerabilities in %v\n", len(vulns), duration)
		for _, vuln := range vulns {
			fmt.Printf("  - [%s] %s: %s\n", vuln.Source, vuln.ID, vuln.Title)
			fmt.Printf("    Severity: %s, CVSS: %s\n", vuln.Severity, vuln.CVSS)
			if len(vuln.Aliases) > 0 {
				fmt.Printf("    Aliases: %v\n", vuln.Aliases)
			}
			if len(vuln.AffectedPackages) > 0 {
				fmt.Printf("    Affected: %d packages\n", len(vuln.AffectedPackages))
			}
		}
	}
}

// useConfigurationDrivenSetup demonstrates loading configuration from file
func useConfigurationDrivenSetup() {
	// In a real application, you would load this from the YAML config file
	// For this example, we'll create the config programmatically

	config := &vulnerability.ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
				BaseURL: "https://api.osv.dev",
				Timeout: 15 * time.Second,
				Options: map[string]interface{}{
					"batch_size":        100,
					"include_withdrawn": false,
				},
			},
			{
				Type:    "github",
				Enabled: true,
				BaseURL: "https://api.github.com/advisories",
				Timeout: 20 * time.Second,
				Options: map[string]interface{}{
					"include_malware":   true,
					"include_withdrawn": false,
				},
			},
		},
		ParallelQueries: true,
		Timeout:         30 * time.Second,
		CacheEnabled:    true,
		CacheTTL:        1 * time.Hour,
		MergeResults:    true,
		DeduplicateByID: true,
		Priority:        []string{"osv", "github"},
	}

	manager := vulnerability.NewManager(config)

	// Example: Search for vulnerabilities by query
	fmt.Println("\n--- Searching for 'lodash' vulnerabilities ---")
	searchResults, err := manager.SearchVulnerabilities("lodash")
	if err != nil {
		log.Printf("Search error: %v", err)
	} else {
		fmt.Printf("Search found %d vulnerabilities\n", len(searchResults))
		for i, vuln := range searchResults {
			if i >= 5 { // Limit output
				fmt.Printf("  ... and %d more\n", len(searchResults)-i)
				break
			}
			fmt.Printf("  - [%s] %s: %s\n", vuln.Source, vuln.ID, vuln.Title)
		}
	}

	// Example: Get specific vulnerability by ID
	fmt.Println("\n--- Getting vulnerability by ID ---")
	vulnID := "GHSA-35jh-r3h4-6jhm" // Example GitHub Security Advisory ID
	vuln, err := manager.GetVulnerabilityByID(vulnID)
	if err != nil {
		log.Printf("Get vulnerability error: %v", err)
	} else {
		fmt.Printf("Found vulnerability: %s\n", vuln.Title)
		fmt.Printf("  Source: %s\n", vuln.Source)
		fmt.Printf("  Severity: %s\n", vuln.Severity)
		fmt.Printf("  Description: %.100s...\n", vuln.Description)
	}
}

// demonstrateAdvancedFeatures shows advanced vulnerability database features
func demonstrateAdvancedFeatures() {
	// Create a context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	// Example of batch vulnerability checking
	packages := []*types.Package{
		{Name: "react", Version: "16.8.0", Registry: "npm"},
		{Name: "vue", Version: "2.6.0", Registry: "npm"},
		{Name: "angular", Version: "8.0.0", Registry: "npm"},
		{Name: "requests", Version: "2.25.0", Registry: "pypi"},
		{Name: "flask", Version: "1.1.0", Registry: "pypi"},
	}

	config := &vulnerability.ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{Type: "osv", Enabled: true},
			{Type: "github", Enabled: true},
		},
		ParallelQueries: true,
		MergeResults:    true,
	}

	manager := vulnerability.NewManager(config)

	fmt.Println("\n=== Batch Vulnerability Checking ===")
	for _, pkg := range packages {
		select {
		case <-ctx.Done():
			fmt.Println("Context timeout reached")
			return
		default:
			vulns, err := manager.CheckVulnerabilities(pkg)
			if err != nil {
				log.Printf("Error checking %s: %v", pkg.Name, err)
				continue
			}

			fmt.Printf("%s@%s: %d vulnerabilities\n", pkg.Name, pkg.Version, len(vulns))

			// Categorize by severity
			severityCounts := make(map[types.Severity]int)
			for _, vuln := range vulns {
				severityCounts[vuln.Severity]++
			}

			for severity, count := range severityCounts {
				if count > 0 {
					fmt.Printf("  %s: %d\n", severity, count)
				}
			}
		}
	}
}

// Example usage in a real application:
// func integrateWithTyposentinel() {
//     // Load configuration from file
//     config := loadVulnerabilityConfig("config/vulnerability_databases.yaml")
//
//     // Create vulnerability manager
//     vulnManager := vulnerability.NewManager(config)
//
//     // Integrate with existing typosentinel scanning
//     scanner := &PackageScanner{
//         VulnerabilityManager: vulnManager,
//         // ... other dependencies
//     }
//
//     // Use in package analysis
//     result := scanner.ScanPackage(packageInfo)
//     if len(result.Vulnerabilities) > 0 {
//         // Handle vulnerabilities found
//         for _, vuln := range result.Vulnerabilities {
//             log.Printf("Vulnerability found: %s (Severity: %s)", vuln.ID, vuln.Severity)
//         }
//     }
// }