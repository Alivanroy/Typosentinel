package analyzer

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"typosentinel/internal/config"
)

func TestNPMAnalyzer_ParsePackageJSON(t *testing.T) {
	// Create temporary directory with package.json
	tempDir, err := os.MkdirTemp("", "npm-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	packageJSON := `{
		"name": "test-project",
		"version": "1.0.0",
		"dependencies": {
			"express": "^4.18.0",
			"lodash": "4.17.21",
			"axios": "~0.27.0"
		},
		"devDependencies": {
			"jest": "^28.0.0",
			"eslint": "8.15.0"
		}
	}`

	packageJSONPath := filepath.Join(tempDir, "package.json")
	err = os.WriteFile(packageJSONPath, []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	cfg := &config.Config{
		Detection: config.DetectionConfig{
			SimilarityThreshold: 0.8,
		},
		Scanner: config.ScannerConfig{
			IncludeDevDeps: true,
			MaxDepth:       5,
		},
	}

	analyzer := New(cfg)

	options := &ScanOptions{
		SimilarityThreshold:    0.8,
		IncludeDevDependencies: true,
	}

	result, err := analyzer.Scan(tempDir, options)

	if err != nil {
		t.Fatalf("Expected successful analysis, got error: %v", err)
	}

	if result == nil {
		t.Error("Expected analysis result, got nil")
	}

	if result.TotalPackages == 0 {
		t.Error("Expected packages to be found")
	}

	// Check that package.json was processed
	if result.Path != tempDir {
		t.Errorf("Expected path %s, got %s", tempDir, result.Path)
	}
}

func TestNPMAnalyzer_ParsePackageLockJSON(t *testing.T) {
	// Create temporary directory with package-lock.json
	tempDir, err := os.MkdirTemp("", "npm-lock-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	packageLockJSON := `{
		"name": "test-project",
		"version": "1.0.0",
		"lockfileVersion": 2,
		"requires": true,
		"packages": {
			"": {
				"name": "test-project",
				"version": "1.0.0"
			},
			"node_modules/express": {
				"version": "4.18.2",
				"resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
				"integrity": "sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ=="
			},
			"node_modules/lodash": {
				"version": "4.17.21",
				"resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
				"integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
			}
		}
	}`

	packageLockPath := filepath.Join(tempDir, "package-lock.json")
	err = os.WriteFile(packageLockPath, []byte(packageLockJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package-lock.json: %v", err)
	}

	cfg := &config.Config{
		Detection: config.DetectionConfig{
			SimilarityThreshold: 0.8,
		},
		Scanner: config.ScannerConfig{
			IncludeDevDeps: false,
			MaxDepth:       3,
		},
	}

	analyzer := New(cfg)

	options := &ScanOptions{
		SimilarityThreshold: 0.8,
	}

	result, err := analyzer.Scan(tempDir, options)

	if err != nil {
		t.Fatalf("Expected successful analysis, got error: %v", err)
	}

	if result == nil {
		t.Error("Expected analysis result, got nil")
	}

	if result.TotalPackages == 0 {
		t.Error("Expected packages to be found")
	}
}

func TestNPMAnalyzer_ParseYarnLock(t *testing.T) {
	// Create temporary directory with yarn.lock
	tempDir, err := os.MkdirTemp("", "yarn-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	yarnLock := `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

express@^4.18.0:
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz#3fabe4619e13d777962531c105c3d4b17a827de"
  integrity sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==

lodash@4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz#679591c564c3bffaae8454cf0b3df370c3d6911c"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==
`

	yarnLockPath := filepath.Join(tempDir, "yarn.lock")
	err = os.WriteFile(yarnLockPath, []byte(yarnLock), 0644)
	if err != nil {
		t.Fatalf("Failed to write yarn.lock: %v", err)
	}

	cfg := &config.Config{
		Detection: config.DetectionConfig{
			SimilarityThreshold: 0.8,
		},
	}

	analyzer := New(cfg)

	options := &ScanOptions{
		SimilarityThreshold: 0.8,
		AllowEmptyProjects:  true,
	}

	result, err := analyzer.Scan(tempDir, options)

	if err != nil {
		t.Fatalf("Expected successful analysis, got error: %v", err)
	}

	if result == nil {
		t.Error("Expected analysis result, got nil")
	}

	if result.TotalPackages == 0 {
		t.Error("Expected packages to be found")
	}
}

func TestNPMAnalyzer_EmptyProject(t *testing.T) {
	// Create empty temporary directory
	tempDir, err := os.MkdirTemp("", "empty-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	cfg := &config.Config{
		Detection: config.DetectionConfig{
			SimilarityThreshold: 0.8,
		},
	}

	analyzer := New(cfg)

	options := &ScanOptions{
		SimilarityThreshold: 0.8,
		AllowEmptyProjects:  true,
	}

	result, err := analyzer.Scan(tempDir, options)

	if err != nil {
		t.Fatalf("Expected successful analysis, got error: %v", err)
	}

	if result == nil {
		t.Error("Expected analysis result, got nil")
	}

	if result.TotalPackages != 0 {
		t.Errorf("Expected no packages, got %d", result.TotalPackages)
	}
}

func TestNPMAnalyzer_InvalidJSON(t *testing.T) {
	// Create temporary directory with invalid package.json
	tempDir, err := os.MkdirTemp("", "invalid-json-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	invalidJSON := `{
		"name": "test-project",
		"version": "1.0.0",
		"dependencies": {
			"express": "^4.18.0",
			"lodash": "4.17.21"
		// Missing closing brace
	}`

	packageJSONPath := filepath.Join(tempDir, "package.json")
	err = os.WriteFile(packageJSONPath, []byte(invalidJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	cfg := &config.Config{
		Detection: config.DetectionConfig{
			SimilarityThreshold: 0.8,
		},
	}

	analyzer := New(cfg)

	options := &ScanOptions{
		SimilarityThreshold: 0.8,
	}

	result, err := analyzer.Scan(tempDir, options)

	// Should handle invalid JSON gracefully
	if err != nil {
		t.Logf("Got expected error for invalid JSON: %v", err)
	}

	if result != nil && result.TotalPackages > 0 {
		t.Error("Expected no packages from invalid JSON")
	}
}

func TestNPMAnalyzer_VersionConstraints(t *testing.T) {
	tests := []struct {
		name        string
		version     string
		expectedOp  string
	}{
		{"Caret constraint", "^4.18.0", "^"}, 
		{"Tilde constraint", "~0.27.0", "~"},
		{"Exact version", "4.17.21", ""},
		{"Greater than", ">1.0.0", ">"},
		{"Greater than equal", ">=1.0.0", ">="},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.expectedOp != "" {
				if !strings.HasPrefix(tt.version, tt.expectedOp) {
					t.Errorf("Expected version %s to start with %s", tt.version, tt.expectedOp)
				}
			} else {
				// Check that it's an exact version (no operators)
				if strings.ContainsAny(tt.version, "^~><=") {
					t.Errorf("Expected exact version, got %s", tt.version)
				}
			}
		})
	}
}

func TestNPMAnalyzer_FileDetection(t *testing.T) {
	tests := []struct {
		name     string
		filename string
		expected string
	}{
		{"Package JSON", "package.json", "npm"},
		{"Package Lock JSON", "package-lock.json", "npm"},
		{"Yarn Lock", "yarn.lock", "npm"},
		{"NPM Shrinkwrap", "npm-shrinkwrap.json", "npm"},
		{"Unknown file", "unknown.txt", ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := &config.Config{
				Detection: config.DetectionConfig{
					SimilarityThreshold: 0.8,
				},
			}

			analyzer := New(cfg)
			fileType, _ := analyzer.detectFileType(tt.filename)
			
			if tt.expected == "" {
				if fileType != "" {
					t.Errorf("Expected empty file type for %s, got %s", tt.filename, fileType)
				}
			} else {
				if fileType != tt.expected {
					t.Errorf("Expected file type %s for %s, got %s", tt.expected, tt.filename, fileType)
				}
			}
		})
	}
}