package policy

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/Alivanroy/Typosentinel/pkg/types"
)

// DefaultVulnerabilityDatabase implements the VulnerabilityDatabase interface
type DefaultVulnerabilityDatabase struct {
	client *http.Client
	config *VulnDBConfig
}

// VulnDBConfig configuration for vulnerability database
type VulnDBConfig struct {
	OSVEndpoint    string        `json:"osv_endpoint"`
	NVDEndpoint    string        `json:"nvd_endpoint"`
	Timeout        time.Duration `json:"timeout"`
	CacheEnabled   bool          `json:"cache_enabled"`
	CacheTTL       time.Duration `json:"cache_ttl"`
	MaxRetries     int           `json:"max_retries"`
	RetryDelay     time.Duration `json:"retry_delay"`
}

// OSVResponse represents the response from OSV API
type OSVResponse struct {
	Vulns []OSVVulnerability `json:"vulns"`
}

// OSVVulnerability represents a vulnerability from OSV
type OSVVulnerability struct {
	ID       string    `json:"id"`
	Summary  string    `json:"summary"`
	Details  string    `json:"details"`
	Severity []Severity `json:"severity"`
	Affected []Affected `json:"affected"`
}

// Severity represents vulnerability severity
type Severity struct {
	Type  string `json:"type"`
	Score string `json:"score"`
}

// Affected represents affected packages
type Affected struct {
	Package    Package    `json:"package"`
	Ranges     []Range    `json:"ranges"`
	Versions   []string   `json:"versions"`
	Introduced string     `json:"introduced"`
	Fixed      string     `json:"fixed"`
}

// Package represents a package in OSV format
type Package struct {
	Name      string `json:"name"`
	Ecosystem string `json:"ecosystem"`
}

// Range represents version ranges
type Range struct {
	Type   string  `json:"type"`
	Events []Event `json:"events"`
}

// Event represents version events
type Event struct {
	Introduced string `json:"introduced"`
	Fixed      string `json:"fixed"`
}

// NewDefaultVulnerabilityDatabase creates a new vulnerability database
func NewDefaultVulnerabilityDatabase(config *VulnDBConfig) *DefaultVulnerabilityDatabase {
	if config == nil {
		config = &VulnDBConfig{
			OSVEndpoint:  "https://api.osv.dev/v1/query",
			NVDEndpoint:  "https://services.nvd.nist.gov/rest/json/cves/2.0",
			Timeout:      30 * time.Second,
			CacheEnabled: true,
			CacheTTL:     1 * time.Hour,
			MaxRetries:   3,
			RetryDelay:   1 * time.Second,
		}
	}

	return &DefaultVulnerabilityDatabase{
		client: &http.Client{
			Timeout: config.Timeout,
		},
		config: config,
	}
}

// CheckVulnerabilities checks for vulnerabilities in a package
func (db *DefaultVulnerabilityDatabase) CheckVulnerabilities(pkg *types.Package) ([]*types.Vulnerability, error) {
	if pkg == nil {
		return nil, fmt.Errorf("package cannot be nil")
	}

	// Query OSV database
	osvVulns, err := db.queryOSV(pkg)
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV: %w", err)
	}

	// Convert OSV vulnerabilities to our format
	vulnerabilities := make([]*types.Vulnerability, 0, len(osvVulns))
	for _, osv := range osvVulns {
		vuln := db.convertOSVToVulnerability(osv, pkg)
		if vuln != nil {
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities, nil
}

// GetSafeVersions returns safe versions for a package
func (db *DefaultVulnerabilityDatabase) GetSafeVersions(pkg *types.Package) ([]string, error) {
	if pkg == nil {
		return nil, fmt.Errorf("package cannot be nil")
	}

	// Get all vulnerabilities for the package
	vulns, err := db.CheckVulnerabilities(pkg)
	if err != nil {
		return nil, fmt.Errorf("failed to check vulnerabilities: %w", err)
	}

	// If no vulnerabilities, current version is safe
	if len(vulns) == 0 {
		return []string{pkg.Version}, nil
	}

	// Extract safe versions from vulnerability data
	safeVersions := make([]string, 0)
	
	// Query OSV for detailed version information
	osvVulns, err := db.queryOSV(pkg)
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV for safe versions: %w", err)
	}

	// Collect fixed versions from vulnerabilities
	fixedVersions := make(map[string]bool)
	for _, osv := range osvVulns {
		for _, affected := range osv.Affected {
			if affected.Fixed != "" {
				fixedVersions[affected.Fixed] = true
			}
			for _, rng := range affected.Ranges {
				for _, event := range rng.Events {
					if event.Fixed != "" {
						fixedVersions[event.Fixed] = true
					}
				}
			}
		}
	}

	// Convert map to slice
	for version := range fixedVersions {
		safeVersions = append(safeVersions, version)
	}

	return safeVersions, nil
}

// queryOSV queries the OSV database for vulnerabilities
func (db *DefaultVulnerabilityDatabase) queryOSV(pkg *types.Package) ([]OSVVulnerability, error) {
	ecosystem := db.mapRegistryToEcosystem(pkg.Registry)
	if ecosystem == "" {
		return nil, fmt.Errorf("unsupported registry: %s", pkg.Registry)
	}

	query := map[string]interface{}{
		"package": map[string]string{
			"name":      pkg.Name,
			"ecosystem": ecosystem,
		},
		"version": pkg.Version,
	}

	queryBytes, err := json.Marshal(query)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal query: %w", err)
	}

	resp, err := db.client.Post(db.config.OSVEndpoint, "application/json", strings.NewReader(string(queryBytes)))
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status %d", resp.StatusCode)
	}

	var osvResp OSVResponse
	if err := json.NewDecoder(resp.Body).Decode(&osvResp); err != nil {
		return nil, fmt.Errorf("failed to decode OSV response: %w", err)
	}

	return osvResp.Vulns, nil
}

// mapRegistryToEcosystem maps package registry to OSV ecosystem
func (db *DefaultVulnerabilityDatabase) mapRegistryToEcosystem(registry string) string {
	switch strings.ToLower(registry) {
	case "npm":
		return "npm"
	case "pypi":
		return "PyPI"
	case "maven":
		return "Maven"
	case "nuget":
		return "NuGet"
	case "gem", "rubygems":
		return "RubyGems"
	case "cargo":
		return "crates.io"
	case "go":
		return "Go"
	case "packagist":
		return "Packagist"
	default:
		return ""
	}
}

// convertOSVToVulnerability converts OSV vulnerability to our format
func (db *DefaultVulnerabilityDatabase) convertOSVToVulnerability(osv OSVVulnerability, pkg *types.Package) *types.Vulnerability {
	severity := "UNKNOWN"
	score := 0.0

	// Extract severity information
	for _, sev := range osv.Severity {
		if sev.Type == "CVSS_V3" {
			severity = "HIGH" // Simplified mapping
			// Parse CVSS score if available
			if sev.Score != "" {
				// Simplified score parsing
				score = 7.0 // Default high score
			}
		}
	}

	// Extract affected versions
	affectedVersions := make([]string, 0)
	for _, affected := range osv.Affected {
		affectedVersions = append(affectedVersions, affected.Versions...)
	}

	// Convert string severity to types.Severity
	var sev types.Severity
	switch severity {
	case "critical":
		sev = types.SeverityCritical
	case "high":
		sev = types.SeverityHigh
	case "medium":
		sev = types.SeverityMedium
	case "low":
		sev = types.SeverityLow
	default:
		sev = types.SeverityUnknown
	}

	return &types.Vulnerability{
		ID:          osv.ID,
		Title:       osv.Summary,
		Description: osv.Details,
		CVSSScore:   score,
		Severity:    sev,
		Package:     pkg.Name,
		Versions:    affectedVersions,
		References:  []string{fmt.Sprintf("https://osv.dev/vulnerability/%s", osv.ID)},
		PublishedAt: time.Now(), // OSV doesn't always provide this
	}
}

// extractFixedVersion extracts the fixed version from OSV vulnerability
func (db *DefaultVulnerabilityDatabase) extractFixedVersion(osv OSVVulnerability) string {
	for _, affected := range osv.Affected {
		if affected.Fixed != "" {
			return affected.Fixed
		}
		for _, rng := range affected.Ranges {
			for _, event := range rng.Events {
				if event.Fixed != "" {
					return event.Fixed
				}
			}
		}
	}
	return ""
}