package vulnerability

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/Alivanroy/Typosentinel/pkg/types"
)

// VulnerabilityDatabase provides access to vulnerability information
type VulnerabilityDatabase interface {
	CheckVulnerabilities(pkg *types.Package) ([]*types.Vulnerability, error)
	GetVulnerabilityByID(id string) (*types.Vulnerability, error)
	SearchVulnerabilities(query string) ([]*types.Vulnerability, error)
}

// CVEDatabase implements vulnerability database using CVE data
type CVEDatabase struct {
	httpClient *http.Client
	apiURL     string
	cache      map[string][]*types.Vulnerability
}

// NewCVEDatabase creates a new CVE database client
func NewCVEDatabase() *CVEDatabase {
	return &CVEDatabase{
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		apiURL: "https://services.nvd.nist.gov/rest/json/cves/2.0",
		cache:  make(map[string][]*types.Vulnerability),
	}
}

// CVEResponse represents the response from NIST CVE API
type CVEResponse struct {
	ResultsPerPage int `json:"resultsPerPage"`
	StartIndex     int `json:"startIndex"`
	TotalResults   int `json:"totalResults"`
	Format         string `json:"format"`
	Version        string `json:"version"`
	Timestamp      string `json:"timestamp"`
	Vulnerabilities []CVEItem `json:"vulnerabilities"`
}

type CVEItem struct {
	CVE CVEData `json:"cve"`
}

type CVEData struct {
	ID               string           `json:"id"`
	SourceIdentifier string           `json:"sourceIdentifier"`
	Published        string           `json:"published"`
	LastModified     string           `json:"lastModified"`
	VulnStatus       string           `json:"vulnStatus"`
	Descriptions     []CVEDescription `json:"descriptions"`
	Metrics          CVEMetrics       `json:"metrics"`
	Configurations   []CVEConfig      `json:"configurations"`
	References       []CVEReference   `json:"references"`
}

type CVEDescription struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type CVEMetrics struct {
	CvssMetricV31 []CVSSMetric `json:"cvssMetricV31"`
	CvssMetricV30 []CVSSMetric `json:"cvssMetricV30"`
	CvssMetricV2  []CVSSMetric `json:"cvssMetricV2"`
}

type CVSSMetric struct {
	Source   string    `json:"source"`
	Type     string    `json:"type"`
	CvssData CVSSData  `json:"cvssData"`
}

type CVSSData struct {
	Version               string  `json:"version"`
	VectorString          string  `json:"vectorString"`
	AttackVector          string  `json:"attackVector"`
	AttackComplexity      string  `json:"attackComplexity"`
	PrivilegesRequired    string  `json:"privilegesRequired"`
	UserInteraction       string  `json:"userInteraction"`
	Scope                 string  `json:"scope"`
	ConfidentialityImpact string  `json:"confidentialityImpact"`
	IntegrityImpact       string  `json:"integrityImpact"`
	AvailabilityImpact    string  `json:"availabilityImpact"`
	BaseScore             float64 `json:"baseScore"`
	BaseSeverity          string  `json:"baseSeverity"`
}

type CVEConfig struct {
	Nodes []CVENode `json:"nodes"`
}

type CVENode struct {
	Operator string    `json:"operator"`
	Negate   bool      `json:"negate"`
	CpeMatch []CPEMatch `json:"cpeMatch"`
}

type CPEMatch struct {
	Vulnerable            bool   `json:"vulnerable"`
	Criteria              string `json:"criteria"`
	VersionStartIncluding string `json:"versionStartIncluding"`
	VersionStartExcluding string `json:"versionStartExcluding"`
	VersionEndIncluding   string `json:"versionEndIncluding"`
	VersionEndExcluding   string `json:"versionEndExcluding"`
	MatchCriteriaId       string `json:"matchCriteriaId"`
}

type CVEReference struct {
	URL    string   `json:"url"`
	Source string   `json:"source"`
	Tags   []string `json:"tags"`
}

// CheckVulnerabilities checks for vulnerabilities in a package
func (db *CVEDatabase) CheckVulnerabilities(pkg *types.Package) ([]*types.Vulnerability, error) {
	// Check cache first
	cacheKey := fmt.Sprintf("%s:%s", pkg.Name, pkg.Version)
	if vulns, exists := db.cache[cacheKey]; exists {
		return vulns, nil
	}

	// Search for vulnerabilities using package name
	vulns, err := db.searchCVEByKeyword(pkg.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to search CVE database: %w", err)
	}

	// Filter vulnerabilities relevant to the package
	relevantVulns := db.filterRelevantVulnerabilities(vulns, pkg)

	// Cache the results
	db.cache[cacheKey] = relevantVulns

	return relevantVulns, nil
}

// GetVulnerabilityByID retrieves a specific vulnerability by ID
func (db *CVEDatabase) GetVulnerabilityByID(id string) (*types.Vulnerability, error) {
	url := fmt.Sprintf("%s?cveId=%s", db.apiURL, id)
	
	resp, err := db.httpClient.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch CVE data: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("CVE API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var cveResp CVEResponse
	if err := json.Unmarshal(body, &cveResp); err != nil {
		return nil, fmt.Errorf("failed to parse CVE response: %w", err)
	}

	if len(cveResp.Vulnerabilities) == 0 {
		return nil, fmt.Errorf("vulnerability %s not found", id)
	}

	return db.convertCVEToVulnerability(cveResp.Vulnerabilities[0]), nil
}

// SearchVulnerabilities searches for vulnerabilities by query
func (db *CVEDatabase) SearchVulnerabilities(query string) ([]*types.Vulnerability, error) {
	return db.searchCVEByKeyword(query)
}

// searchCVEByKeyword searches CVE database by keyword
func (db *CVEDatabase) searchCVEByKeyword(keyword string) ([]*types.Vulnerability, error) {
	url := fmt.Sprintf("%s?keywordSearch=%s&resultsPerPage=100", db.apiURL, keyword)
	
	resp, err := db.httpClient.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to search CVE database: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("CVE API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var cveResp CVEResponse
	if err := json.Unmarshal(body, &cveResp); err != nil {
		return nil, fmt.Errorf("failed to parse CVE response: %w", err)
	}

	vulns := make([]*types.Vulnerability, 0, len(cveResp.Vulnerabilities))
	for _, cveItem := range cveResp.Vulnerabilities {
		vulns = append(vulns, db.convertCVEToVulnerability(cveItem))
	}

	return vulns, nil
}

// filterRelevantVulnerabilities filters vulnerabilities relevant to the package
func (db *CVEDatabase) filterRelevantVulnerabilities(vulns []*types.Vulnerability, pkg *types.Package) []*types.Vulnerability {
	relevant := make([]*types.Vulnerability, 0)
	
	for _, vuln := range vulns {
		// Check if vulnerability description mentions the package
		if strings.Contains(strings.ToLower(vuln.Description), strings.ToLower(pkg.Name)) {
			relevant = append(relevant, vuln)
			continue
		}
		
		// Check if any affected packages match
		for _, affected := range vuln.AffectedPackages {
			if strings.EqualFold(affected.Name, pkg.Name) {
				// Check version range if specified
				if affected.VersionRange == "" || db.isVersionInRange(pkg.Version, affected.VersionRange) {
					relevant = append(relevant, vuln)
					break
				}
			}
		}
	}
	
	return relevant
}

// convertCVEToVulnerability converts CVE data to internal vulnerability format
func (db *CVEDatabase) convertCVEToVulnerability(cveItem CVEItem) *types.Vulnerability {
	cve := cveItem.CVE
	
	// Get description
	description := "No description available"
	for _, desc := range cve.Descriptions {
		if desc.Lang == "en" {
			description = desc.Value
			break
		}
	}
	
	// Get CVSS score and severity
	severity := types.SeverityUnknown
	cvssScore := 0.0
	
	if len(cve.Metrics.CvssMetricV31) > 0 {
		metric := cve.Metrics.CvssMetricV31[0]
		cvssScore = metric.CvssData.BaseScore
		severity = db.convertCVSSSeverity(metric.CvssData.BaseSeverity)
	} else if len(cve.Metrics.CvssMetricV30) > 0 {
		metric := cve.Metrics.CvssMetricV30[0]
		cvssScore = metric.CvssData.BaseScore
		severity = db.convertCVSSSeverity(metric.CvssData.BaseSeverity)
	} else if len(cve.Metrics.CvssMetricV2) > 0 {
		metric := cve.Metrics.CvssMetricV2[0]
		cvssScore = metric.CvssData.BaseScore
		severity = db.convertCVSSSeverity(metric.CvssData.BaseSeverity)
	}
	
	// Parse published date
	publishedTime, _ := time.Parse(time.RFC3339, cve.Published)
	
	// Extract affected packages from configurations
	affectedPackages := db.extractAffectedPackages(cve.Configurations)
	
	// Convert references
	references := make([]string, 0, len(cve.References))
	for _, ref := range cve.References {
		references = append(references, ref.URL)
	}
	
	return &types.Vulnerability{
		ID:               cve.ID,
		Title:            cve.ID,
		Description:      description,
		Severity:         severity,
		CVSSScore:        cvssScore,
		PublishedAt:      publishedTime,
		AffectedPackages: affectedPackages,
		References:       references,
		Source:           "NIST CVE",
		Metadata: map[string]interface{}{
			"sourceIdentifier": cve.SourceIdentifier,
			"vulnStatus":       cve.VulnStatus,
			"lastModified":     cve.LastModified,
		},
	}
}

// convertCVSSSeverity converts CVSS severity string to internal severity
func (db *CVEDatabase) convertCVSSSeverity(cvssSevertiy string) types.Severity {
	switch strings.ToUpper(cvssSevertiy) {
	case "CRITICAL":
		return types.SeverityCritical
	case "HIGH":
		return types.SeverityHigh
	case "MEDIUM":
		return types.SeverityMedium
	case "LOW":
		return types.SeverityLow
	default:
		return types.SeverityUnknown
	}
}

// extractAffectedPackages extracts affected packages from CVE configurations
func (db *CVEDatabase) extractAffectedPackages(configs []CVEConfig) []types.AffectedPackage {
	packages := make([]types.AffectedPackage, 0)
	
	for _, config := range configs {
		for _, node := range config.Nodes {
			for _, cpeMatch := range node.CpeMatch {
				if cpeMatch.Vulnerable {
					// Parse CPE criteria to extract package information
					pkg := db.parseCPECriteria(cpeMatch.Criteria)
					if pkg.Name != "" {
						// Build version range from CPE match
						versionRange := db.buildVersionRange(cpeMatch)
						pkg.VersionRange = versionRange
						packages = append(packages, pkg)
					}
				}
			}
		}
	}
	
	return packages
}

// parseCPECriteria parses CPE criteria to extract package information
func (db *CVEDatabase) parseCPECriteria(criteria string) types.AffectedPackage {
	// CPE format: cpe:2.3:a:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
	parts := strings.Split(criteria, ":")
	if len(parts) < 5 {
		return types.AffectedPackage{}
	}
	
	vendor := parts[3]
	product := parts[4]
	version := ""
	if len(parts) > 5 && parts[5] != "*" {
		version = parts[5]
	}
	
	name := product
	if vendor != "*" && vendor != product {
		name = fmt.Sprintf("%s/%s", vendor, product)
	}
	
	return types.AffectedPackage{
		Name:    name,
		Version: version,
	}
}

// buildVersionRange builds version range from CPE match
func (db *CVEDatabase) buildVersionRange(cpeMatch CPEMatch) string {
	var parts []string
	
	if cpeMatch.VersionStartIncluding != "" {
		parts = append(parts, fmt.Sprintf(">=%s", cpeMatch.VersionStartIncluding))
	}
	if cpeMatch.VersionStartExcluding != "" {
		parts = append(parts, fmt.Sprintf(">%s", cpeMatch.VersionStartExcluding))
	}
	if cpeMatch.VersionEndIncluding != "" {
		parts = append(parts, fmt.Sprintf("<=%s", cpeMatch.VersionEndIncluding))
	}
	if cpeMatch.VersionEndExcluding != "" {
		parts = append(parts, fmt.Sprintf("<%s", cpeMatch.VersionEndExcluding))
	}
	
	return strings.Join(parts, ",")
}

// isVersionInRange checks if a version is within the specified range
func (db *CVEDatabase) isVersionInRange(version, versionRange string) bool {
	if versionRange == "" {
		return true
	}
	
	// Simple version range checking - in production, use a proper semver library
	constraints := strings.Split(versionRange, ",")
	for _, constraint := range constraints {
		constraint = strings.TrimSpace(constraint)
		if !db.checkVersionConstraint(version, constraint) {
			return false
		}
	}
	
	return true
}

// checkVersionConstraint checks if version satisfies a single constraint
func (db *CVEDatabase) checkVersionConstraint(version, constraint string) bool {
	if constraint == "" {
		return true
	}
	
	// Simple string comparison - in production, use proper semver comparison
	if strings.HasPrefix(constraint, ">=") {
		target := strings.TrimPrefix(constraint, ">=")
		return version >= target
	}
	if strings.HasPrefix(constraint, "<=") {
		target := strings.TrimPrefix(constraint, "<=")
		return version <= target
	}
	if strings.HasPrefix(constraint, ">") {
		target := strings.TrimPrefix(constraint, ">")
		return version > target
	}
	if strings.HasPrefix(constraint, "<") {
		target := strings.TrimPrefix(constraint, "<")
		return version < target
	}
	if strings.HasPrefix(constraint, "=") {
		target := strings.TrimPrefix(constraint, "=")
		return version == target
	}
	
	return version == constraint
}