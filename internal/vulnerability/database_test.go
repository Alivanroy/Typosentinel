package vulnerability

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/Alivanroy/Typosentinel/pkg/types"
)

// Mock CVE response for testing
func mockCVEResponse() CVEResponse {
	return CVEResponse{
		ResultsPerPage: 1,
		StartIndex:     0,
		TotalResults:   1,
		Format:         "NVD_CVE",
		Version:        "2.0",
		Timestamp:      "2024-01-01T00:00:00.000",
		Vulnerabilities: []CVEItem{
			{
				CVE: CVEData{
					ID:               "CVE-2024-0001",
					SourceIdentifier: "test@example.com",
					Published:        "2024-01-01T00:00:00.000",
					LastModified:     "2024-01-01T00:00:00.000",
					VulnStatus:       "Analyzed",
					Descriptions: []CVEDescription{
						{
							Lang:  "en",
							Value: "Test vulnerability in test-package",
						},
					},
					Metrics: CVEMetrics{
						CvssMetricV31: []CVSSMetric{
							{
								Source: "nvd@nist.gov",
								Type:   "Primary",
								CvssData: CVSSData{
									Version:      "3.1",
									VectorString: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
									BaseScore:    9.8,
									BaseSeverity: "CRITICAL",
								},
							},
						},
					},
					Configurations: []CVEConfig{
						{
							Nodes: []CVENode{
								{
									Operator: "OR",
									Negate:   false,
									CpeMatch: []CPEMatch{
										{
											Vulnerable:            true,
											Criteria:              "cpe:2.3:a:test:test-package:1.0.0:*:*:*:*:*:*:*",
											VersionStartIncluding: "1.0.0",
											VersionEndExcluding:   "2.0.0",
										},
									},
								},
							},
						},
					},
					References: []CVEReference{
						{
							URL:    "https://example.com/advisory",
							Source: "example.com",
							Tags:   []string{"Vendor Advisory"},
						},
					},
				},
			},
		},
	}
}

func TestNewCVEDatabase(t *testing.T) {
	db := NewCVEDatabase()
	if db == nil {
		t.Fatal("NewCVEDatabase returned nil")
	}
	if db.httpClient == nil {
		t.Error("httpClient should not be nil")
	}
	if db.apiURL == "" {
		t.Error("apiURL should not be empty")
	}
	if db.cache == nil {
		t.Error("cache should not be nil")
	}
}

func TestCheckVulnerabilities(t *testing.T) {
	// Create mock server
	mockResp := mockCVEResponse()
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(mockResp)
	}))
	defer server.Close()

	// Create database with mock server URL
	db := NewCVEDatabase()
	db.apiURL = server.URL

	// Test package
	pkg := &types.Package{
		Name:    "test-package",
		Version: "1.5.0",
	}

	// First call - should hit API
	vulns, err := db.CheckVulnerabilities(pkg)
	if err != nil {
		t.Fatalf("CheckVulnerabilities failed: %v", err)
	}

	if len(vulns) != 1 {
		t.Errorf("Expected 1 vulnerability, got %d", len(vulns))
	}

	if vulns[0].ID != "CVE-2024-0001" {
		t.Errorf("Expected CVE-2024-0001, got %s", vulns[0].ID)
	}

	// Second call - should hit cache
	vulns2, err := db.CheckVulnerabilities(pkg)
	if err != nil {
		t.Fatalf("CheckVulnerabilities failed on cached call: %v", err)
	}

	if len(vulns2) != len(vulns) {
		t.Error("Cache should return same results")
	}
}

func TestGetVulnerabilityByID(t *testing.T) {
	// Create mock server
	mockResp := mockCVEResponse()
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(mockResp)
	}))
	defer server.Close()

	// Create database with mock server URL
	db := NewCVEDatabase()
	db.apiURL = server.URL

	vuln, err := db.GetVulnerabilityByID("CVE-2024-0001")
	if err != nil {
		t.Fatalf("GetVulnerabilityByID failed: %v", err)
	}

	if vuln.ID != "CVE-2024-0001" {
		t.Errorf("Expected CVE-2024-0001, got %s", vuln.ID)
	}

	if vuln.Severity != types.SeverityCritical {
		t.Errorf("Expected Critical severity, got %v", vuln.Severity)
	}

	if vuln.CVSSScore != 9.8 {
		t.Errorf("Expected CVSS score 9.8, got %f", vuln.CVSSScore)
	}
}

func TestGetVulnerabilityByID_NotFound(t *testing.T) {
	// Create mock server that returns empty results
	emptyResp := CVEResponse{
		Vulnerabilities: []CVEItem{},
	}
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(emptyResp)
	}))
	defer server.Close()

	db := NewCVEDatabase()
	db.apiURL = server.URL

	_, err := db.GetVulnerabilityByID("CVE-NONEXISTENT")
	if err == nil {
		t.Error("Expected error for non-existent CVE")
	}
}

func TestSearchVulnerabilities(t *testing.T) {
	// Create mock server
	mockResp := mockCVEResponse()
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(mockResp)
	}))
	defer server.Close()

	db := NewCVEDatabase()
	db.apiURL = server.URL

	vulns, err := db.SearchVulnerabilities("test-package")
	if err != nil {
		t.Fatalf("SearchVulnerabilities failed: %v", err)
	}

	if len(vulns) != 1 {
		t.Errorf("Expected 1 vulnerability, got %d", len(vulns))
	}
}

func TestConvertCVSSSeverity(t *testing.T) {
	db := NewCVEDatabase()

	tests := []struct {
		input    string
		expected types.Severity
	}{
		{"CRITICAL", types.SeverityCritical},
		{"HIGH", types.SeverityHigh},
		{"MEDIUM", types.SeverityMedium},
		{"LOW", types.SeverityLow},
		{"UNKNOWN", types.SeverityUnknown},
		{"invalid", types.SeverityUnknown},
	}

	for _, test := range tests {
		result := db.convertCVSSSeverity(test.input)
		if result != test.expected {
			t.Errorf("convertCVSSSeverity(%s) = %v, expected %v", test.input, result, test.expected)
		}
	}
}

func TestParseCPECriteria(t *testing.T) {
	db := NewCVEDatabase()

	tests := []struct {
		input        string
		expectedName string
	}{
		{"cpe:2.3:a:vendor:product:1.0.0:*:*:*:*:*:*:*", "vendor/product"},
		{"cpe:2.3:a:*:product:1.0.0:*:*:*:*:*:*:*", "product"},
		{"cpe:2.3:a:product:product:1.0.0:*:*:*:*:*:*:*", "product"},
		{"invalid:cpe", ""},
	}

	for _, test := range tests {
		result := db.parseCPECriteria(test.input)
		if result.Name != test.expectedName {
			t.Errorf("parseCPECriteria(%s).Name = %s, expected %s", test.input, result.Name, test.expectedName)
		}
	}
}

func TestBuildVersionRange(t *testing.T) {
	db := NewCVEDatabase()

	tests := []struct {
		input    CPEMatch
		expected string
	}{
		{
			CPEMatch{
				VersionStartIncluding: "1.0.0",
				VersionEndExcluding:   "2.0.0",
			},
			">=1.0.0,<2.0.0",
		},
		{
			CPEMatch{
				VersionStartExcluding: "0.9.0",
				VersionEndIncluding:   "1.5.0",
			},
			">0.9.0,<=1.5.0",
		},
		{
			CPEMatch{},
			"",
		},
	}

	for _, test := range tests {
		result := db.buildVersionRange(test.input)
		if result != test.expected {
			t.Errorf("buildVersionRange() = %s, expected %s", result, test.expected)
		}
	}
}

func TestIsVersionInRange(t *testing.T) {
	db := NewCVEDatabase()

	tests := []struct {
		version  string
		range_   string
		expected bool
	}{
		{"1.5.0", ">=1.0.0,<2.0.0", true},
		{"0.9.0", ">=1.0.0,<2.0.0", false},
		{"2.0.0", ">=1.0.0,<2.0.0", false},
		{"1.0.0", ">=1.0.0,<2.0.0", true},
		{"1.5.0", "", true},
		{"1.5.0", "=1.5.0", true},
		{"1.5.0", "=1.4.0", false},
	}

	for _, test := range tests {
		result := db.isVersionInRange(test.version, test.range_)
		if result != test.expected {
			t.Errorf("isVersionInRange(%s, %s) = %v, expected %v", test.version, test.range_, result, test.expected)
		}
	}
}

func TestCheckVersionConstraint(t *testing.T) {
	db := NewCVEDatabase()

	tests := []struct {
		version    string
		constraint string
		expected   bool
	}{
		{"1.5.0", ">=1.0.0", true},
		{"0.9.0", ">=1.0.0", false},
		{"1.5.0", "<=2.0.0", true},
		{"2.1.0", "<=2.0.0", false},
		{"1.5.0", ">1.0.0", true},
		{"1.0.0", ">1.0.0", false},
		{"1.5.0", "<2.0.0", true},
		{"2.0.0", "<2.0.0", false},
		{"1.5.0", "=1.5.0", true},
		{"1.5.0", "=1.4.0", false},
		{"1.5.0", "1.5.0", true},
		{"1.5.0", "", true},
	}

	for _, test := range tests {
		result := db.checkVersionConstraint(test.version, test.constraint)
		if result != test.expected {
			t.Errorf("checkVersionConstraint(%s, %s) = %v, expected %v", test.version, test.constraint, result, test.expected)
		}
	}
}

func TestFilterRelevantVulnerabilities(t *testing.T) {
	db := NewCVEDatabase()

	// Create test vulnerabilities
	vulns := []*types.Vulnerability{
		{
			ID:          "CVE-2024-0001",
			Description: "Vulnerability in test-package",
		},
		{
			ID:          "CVE-2024-0002",
			Description: "Vulnerability in other-package",
			AffectedPackages: []types.AffectedPackage{
				{Name: "test-package", VersionRange: ">=1.0.0,<2.0.0"},
			},
		},
		{
			ID:          "CVE-2024-0003",
			Description: "Unrelated vulnerability",
		},
	}

	pkg := &types.Package{
		Name:    "test-package",
		Version: "1.5.0",
	}

	relevant := db.filterRelevantVulnerabilities(vulns, pkg)

	if len(relevant) != 2 {
		t.Errorf("Expected 2 relevant vulnerabilities, got %d", len(relevant))
	}

	// Check that the correct vulnerabilities are included
	found1, found2 := false, false
	for _, vuln := range relevant {
		if vuln.ID == "CVE-2024-0001" {
			found1 = true
		}
		if vuln.ID == "CVE-2024-0002" {
			found2 = true
		}
	}

	if !found1 || !found2 {
		t.Error("Expected CVE-2024-0001 and CVE-2024-0002 to be relevant")
	}
}

func TestHTTPErrors(t *testing.T) {
	// Test server error
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	}))
	defer server.Close()

	db := NewCVEDatabase()
	db.apiURL = server.URL

	_, err := db.GetVulnerabilityByID("CVE-2024-0001")
	if err == nil {
		t.Error("Expected error for server error response")
	}

	// Test invalid JSON
	server2 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte("invalid json"))
	}))
	defer server2.Close()

	db.apiURL = server2.URL
	_, err = db.GetVulnerabilityByID("CVE-2024-0001")
	if err == nil {
		t.Error("Expected error for invalid JSON response")
	}
}

func TestConvertCVEToVulnerability(t *testing.T) {
	db := NewCVEDatabase()
	cveItem := mockCVEResponse().Vulnerabilities[0]

	vuln := db.convertCVEToVulnerability(cveItem)

	if vuln.ID != "CVE-2024-0001" {
		t.Errorf("Expected ID CVE-2024-0001, got %s", vuln.ID)
	}

	if vuln.Severity != types.SeverityCritical {
		t.Errorf("Expected Critical severity, got %v", vuln.Severity)
	}

	if vuln.CVSSScore != 9.8 {
		t.Errorf("Expected CVSS score 9.8, got %f", vuln.CVSSScore)
	}

	if len(vuln.References) != 1 {
		t.Errorf("Expected 1 reference, got %d", len(vuln.References))
	}

	if vuln.Source != "NIST CVE" {
		t.Errorf("Expected source 'NIST CVE', got %s", vuln.Source)
	}

	// Test with no descriptions
	cveItem.CVE.Descriptions = []CVEDescription{}
	vuln2 := db.convertCVEToVulnerability(cveItem)
	if vuln2.Description != "No description available" {
		t.Errorf("Expected default description, got %s", vuln2.Description)
	}
}
