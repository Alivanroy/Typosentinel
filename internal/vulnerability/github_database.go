package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/Alivanroy/Typosentinel/pkg/types"
)

// GitHubAdvisoryDatabase implements vulnerability database using GitHub Security Advisory API
// GitHub Security Advisory Database is a comprehensive, open-source vulnerability database
type GitHubAdvisoryDatabase struct {
	httpClient *http.Client
	apiURL     string
	apiToken   string // Optional GitHub token for higher rate limits
	cache      map[string][]*types.Vulnerability
}

// NewGitHubAdvisoryDatabase creates a new GitHub Advisory database client
func NewGitHubAdvisoryDatabase(apiToken string) *GitHubAdvisoryDatabase {
	return &GitHubAdvisoryDatabase{
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		apiURL:   "https://api.github.com/advisories",
		apiToken: apiToken,
		cache:    make(map[string][]*types.Vulnerability),
	}
}

// GitHubAdvisory represents a GitHub Security Advisory
type GitHubAdvisory struct {
	GHSAID                string                `json:"ghsa_id"`
	CVEID                 string                `json:"cve_id"`
	URL                   string                `json:"url"`
	HTMLURL               string                `json:"html_url"`
	RepositoryAdvisoryURL string                `json:"repository_advisory_url"`
	Summary               string                `json:"summary"`
	Description           string                `json:"description"`
	Type                  string                `json:"type"`
	Severity              string                `json:"severity"`
	SourceCodeLocation    string                `json:"source_code_location"`
	Identifiers           []GitHubIdentifier    `json:"identifiers"`
	References            []GitHubReference     `json:"references"`
	PublishedAt           string                `json:"published_at"`
	UpdatedAt             string                `json:"updated_at"`
	WithdrawnAt           string                `json:"withdrawn_at"`
	Vulnerabilities       []GitHubVulnerability `json:"vulnerabilities"`
	CVSS                  GitHubCVSS            `json:"cvss"`
	CWEs                  []GitHubCWE           `json:"cwes"`
	Credits               []GitHubCredit        `json:"credits"`
}

// GitHubIdentifier represents advisory identifiers
type GitHubIdentifier struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

// GitHubReference represents external references
type GitHubReference struct {
	URL string `json:"url"`
}

// GitHubVulnerability represents vulnerable packages
type GitHubVulnerability struct {
	Package                GitHubPackage `json:"package"`
	Severity               string        `json:"severity"`
	VulnerableVersionRange string        `json:"vulnerable_version_range"`
	FirstPatchedVersion    string        `json:"first_patched_version"`
}

// GitHubPackage represents a package
type GitHubPackage struct {
	Ecosystem string `json:"ecosystem"`
	Name      string `json:"name"`
}

// GitHubCVSS represents CVSS information
type GitHubCVSS struct {
	Score        float64 `json:"score"`
	VectorString string  `json:"vector_string"`
}

// GitHubCWE represents Common Weakness Enumeration
type GitHubCWE struct {
	CWEID string `json:"cwe_id"`
	Name  string `json:"name"`
}

// GitHubCredit represents advisory credits
type GitHubCredit struct {
	Login string `json:"login"`
	Type  string `json:"type"`
}

// CheckVulnerabilities checks for vulnerabilities in a package using GitHub Advisory API
func (db *GitHubAdvisoryDatabase) CheckVulnerabilities(pkg *types.Package) ([]*types.Vulnerability, error) {
	// Check cache first
	cacheKey := fmt.Sprintf("%s:%s:%s", pkg.Name, pkg.Version, pkg.Registry)
	if vulns, exists := db.cache[cacheKey]; exists {
		return vulns, nil
	}

	// Map registry to GitHub ecosystem
	ecosystem := db.mapRegistryToEcosystem(pkg.Registry)
	if ecosystem == "" {
		return nil, fmt.Errorf("unsupported registry: %s", pkg.Registry)
	}

	// Search for advisories affecting this package
	advisories, err := db.searchAdvisories(ecosystem, pkg.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to search GitHub advisories: %w", err)
	}

	// Convert GitHub advisories to internal format
	result := make([]*types.Vulnerability, 0, len(advisories))
	for _, advisory := range advisories {
		// Check if this advisory affects the specific version
		if db.isVersionAffected(pkg.Version, advisory.Vulnerabilities) {
			converted := db.convertGitHubToVulnerability(advisory)
			result = append(result, converted)
		}
	}

	// Cache the results
	db.cache[cacheKey] = result

	return result, nil
}

// GetVulnerabilityByID retrieves a specific vulnerability by ID from GitHub
func (db *GitHubAdvisoryDatabase) GetVulnerabilityByID(id string) (*types.Vulnerability, error) {
	url := fmt.Sprintf("%s/%s", db.apiURL, id)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Add authentication if token is provided
	if db.apiToken != "" {
		req.Header.Set("Authorization", fmt.Sprintf("token %s", db.apiToken))
	}
	req.Header.Set("Accept", "application/vnd.github.v3+json")

	resp, err := db.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch GitHub advisory: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var advisory GitHubAdvisory
	if err := json.Unmarshal(body, &advisory); err != nil {
		return nil, fmt.Errorf("failed to parse GitHub advisory: %w", err)
	}

	return db.convertGitHubToVulnerability(advisory), nil
}

// SearchVulnerabilities searches for vulnerabilities by query
func (db *GitHubAdvisoryDatabase) SearchVulnerabilities(query string) ([]*types.Vulnerability, error) {
	// Parse query format: "ecosystem:package_name" or just "package_name"
	parts := strings.Split(query, ":")
	var ecosystem, packageName string

	if len(parts) == 2 {
		ecosystem = parts[0]
		packageName = parts[1]
	} else {
		packageName = query
		// Try all ecosystems if not specified
		ecosystem = ""
	}

	advisories, err := db.searchAdvisories(ecosystem, packageName)
	if err != nil {
		return nil, err
	}

	result := make([]*types.Vulnerability, 0, len(advisories))
	for _, advisory := range advisories {
		converted := db.convertGitHubToVulnerability(advisory)
		result = append(result, converted)
	}

	return result, nil
}

// searchAdvisories searches GitHub Security Advisories
func (db *GitHubAdvisoryDatabase) searchAdvisories(ecosystem, packageName string) ([]GitHubAdvisory, error) {
	url := db.apiURL
	params := []string{}

	if ecosystem != "" {
		params = append(params, fmt.Sprintf("ecosystem=%s", ecosystem))
	}
	if packageName != "" {
		params = append(params, fmt.Sprintf("affects=%s", packageName))
	}

	if len(params) > 0 {
		url += "?" + strings.Join(params, "&")
	}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Add authentication if token is provided
	if db.apiToken != "" {
		req.Header.Set("Authorization", fmt.Sprintf("token %s", db.apiToken))
	}
	req.Header.Set("Accept", "application/vnd.github.v3+json")

	resp, err := db.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to search GitHub advisories: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	var advisories []GitHubAdvisory
	if err := json.Unmarshal(body, &advisories); err != nil {
		return nil, fmt.Errorf("failed to parse GitHub advisories: %w", err)
	}

	return advisories, nil
}

// mapRegistryToEcosystem maps package registry to GitHub ecosystem
func (db *GitHubAdvisoryDatabase) mapRegistryToEcosystem(registry string) string {
	switch strings.ToLower(registry) {
	case "npm":
		return "npm"
	case "pypi":
		return "pip"
	case "go":
		return "go"
	case "maven":
		return "maven"
	case "nuget":
		return "nuget"
	case "packagist":
		return "composer"
	case "rubygems":
		return "rubygems"
	case "crates.io":
		return "cargo"
	default:
		return ""
	}
}

// isVersionAffected checks if a specific version is affected by vulnerabilities
func (db *GitHubAdvisoryDatabase) isVersionAffected(version string, vulnerabilities []GitHubVulnerability) bool {
	for _, vuln := range vulnerabilities {
		// Simple version range checking - in production, use a proper semver library
		if vuln.VulnerableVersionRange != "" {
			// This is a simplified check - implement proper version range parsing
			if strings.Contains(vuln.VulnerableVersionRange, version) {
				return true
			}
			// Check for range patterns like "< 1.2.3", ">= 1.0.0", etc.
			if db.versionInRange(version, vuln.VulnerableVersionRange) {
				return true
			}
		}
	}
	return false
}

// versionInRange checks if version falls within the vulnerable range
func (db *GitHubAdvisoryDatabase) versionInRange(version, versionRange string) bool {
	// Simplified version range checking
	// In production, use a proper semver library like github.com/Masterminds/semver
	if strings.Contains(versionRange, "<") && !strings.Contains(versionRange, "=") {
		return true // Simplified: assume vulnerable for now
	}
	if strings.Contains(versionRange, ">=") {
		return true // Simplified: assume vulnerable for now
	}
	return false
}

// convertGitHubToVulnerability converts GitHub advisory to internal format
func (db *GitHubAdvisoryDatabase) convertGitHubToVulnerability(advisory GitHubAdvisory) *types.Vulnerability {
	vuln := &types.Vulnerability{
		ID:          advisory.GHSAID,
		Title:       advisory.Summary,
		Description: advisory.Description,
		Published:   advisory.PublishedAt,
		Modified:    advisory.UpdatedAt,
		References:  make([]string, 0, len(advisory.References)+1),
		Severity:    db.mapGitHubSeverity(advisory.Severity),
		Source:      "github",
	}

	// Add CVE ID as alias if available
	if advisory.CVEID != "" {
		vuln.Aliases = append(vuln.Aliases, advisory.CVEID)
	}

	// Add GitHub URL as reference
	if advisory.HTMLURL != "" {
		vuln.References = append(vuln.References, advisory.HTMLURL)
	}

	// Convert references
	for _, ref := range advisory.References {
		vuln.References = append(vuln.References, ref.URL)
	}

	// Add CVSS information
	if advisory.CVSS.Score > 0 {
		vuln.CVSS = fmt.Sprintf("%.1f", advisory.CVSS.Score)
		if advisory.CVSS.VectorString != "" {
			vuln.CVSS = advisory.CVSS.VectorString
		}
	}

	// Extract affected packages
	for _, ghVuln := range advisory.Vulnerabilities {
		vuln.AffectedPackages = append(vuln.AffectedPackages, types.AffectedPackage{
			Name:      ghVuln.Package.Name,
			Ecosystem: ghVuln.Package.Ecosystem,
			Versions:  []string{ghVuln.VulnerableVersionRange},
		})
	}

	return vuln
}

// mapGitHubSeverity maps GitHub severity to internal severity
func (db *GitHubAdvisoryDatabase) mapGitHubSeverity(severity string) types.Severity {
	switch strings.ToLower(severity) {
	case "critical":
		return types.SeverityCritical
	case "high":
		return types.SeverityHigh
	case "medium", "moderate":
		return types.SeverityMedium
	case "low":
		return types.SeverityLow
	default:
		return types.SeverityLow
	}
}

// Update refreshes the vulnerability database cache
func (db *GitHubAdvisoryDatabase) Update(ctx context.Context) error {
	// GitHub Advisory Database is always up-to-date via API, so we just clear the cache
	db.cache = make(map[string][]*types.Vulnerability)
	return nil
}
