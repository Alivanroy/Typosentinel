package vulnerability

import (
	"testing"
	"time"

	"github.com/Alivanroy/Typosentinel/pkg/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestOSVDatabaseIntegration tests the OSV database integration
func TestOSVDatabaseIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	db := NewOSVDatabase()
	require.NotNil(t, db)

	// Test with a known vulnerable package
	pkg := &types.Package{
		Name:     "lodash",
		Version:  "4.17.20",
		Registry: "npm",
	}

	vulns, err := db.CheckVulnerabilities(pkg)
	assert.NoError(t, err)
	// Note: We don't assert on the number of vulnerabilities as it may change over time
	// but we verify the structure is correct
	for _, vuln := range vulns {
		assert.NotEmpty(t, vuln.ID)
		assert.NotEmpty(t, vuln.Title)
		assert.Equal(t, "osv", vuln.Source)
	}
}

// TestGitHubAdvisoryDatabaseIntegration tests the GitHub Advisory database integration
func TestGitHubAdvisoryDatabaseIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	db := NewGitHubAdvisoryDatabase("") // No token for test
	require.NotNil(t, db)

	// Test with a known vulnerable package
	pkg := &types.Package{
		Name:     "lodash",
		Version:  "4.17.20",
		Registry: "npm",
	}

	vulns, err := db.CheckVulnerabilities(pkg)
	// Note: This might fail due to rate limiting without authentication
	if err != nil {
		t.Logf("GitHub API error (expected without token): %v", err)
		return
	}

	for _, vuln := range vulns {
		assert.NotEmpty(t, vuln.ID)
		assert.NotEmpty(t, vuln.Title)
		assert.Equal(t, "github", vuln.Source)
	}
}

// TestVulnerabilityManagerIntegration tests the vulnerability manager with multiple databases
func TestVulnerabilityManagerIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	config := &ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
				Timeout: 15 * time.Second,
			},
			// Note: GitHub database disabled in test to avoid rate limiting
			// {
			//     Type:    "github",
			//     Enabled: true,
			//     Timeout: 20 * time.Second,
			// },
		},
		ParallelQueries:  true,
		Timeout:          30 * time.Second,
		MergeResults:     true,
		DeduplicateByID:  true,
		Priority:         []string{"osv", "github"},
	}

	manager := NewManager(config)
	require.NotNil(t, manager)

	// Verify manager setup
	assert.Equal(t, 1, manager.GetDatabaseCount())
	dbNames := manager.GetDatabaseNames()
	assert.Contains(t, dbNames, "osv")

	// Test vulnerability checking
	pkg := &types.Package{
		Name:     "lodash",
		Version:  "4.17.20",
		Registry: "npm",
	}

	vulns, err := manager.CheckVulnerabilities(pkg)
	assert.NoError(t, err)

	// Verify vulnerability structure
	for _, vuln := range vulns {
		assert.NotEmpty(t, vuln.ID)
		assert.NotEmpty(t, vuln.Title)
		assert.NotEmpty(t, vuln.Source)
		assert.NotEqual(t, types.SeverityUnknown, vuln.Severity)
	}
}

// TestVulnerabilityManagerSearch tests the search functionality
func TestVulnerabilityManagerSearch(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	config := &ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
				Timeout: 15 * time.Second,
			},
		},
		ParallelQueries: false, // Sequential for predictable testing
		MergeResults:    true,
	}

	manager := NewManager(config)
	require.NotNil(t, manager)

	// Test search functionality
	vulns, err := manager.SearchVulnerabilities("npm:lodash")
	assert.NoError(t, err)

	// Verify search results
	for _, vuln := range vulns {
		assert.NotEmpty(t, vuln.ID)
		assert.NotEmpty(t, vuln.Title)
		assert.Equal(t, "osv", vuln.Source)
	}
}

// TestVulnerabilityTypes tests the vulnerability type structures
func TestVulnerabilityTypes(t *testing.T) {
	// Test Vulnerability struct
	vuln := &types.Vulnerability{
		ID:          "TEST-001",
		Title:       "Test Vulnerability",
		Description: "A test vulnerability",
		Severity:    types.SeverityHigh,
		CVSS:        "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
		CVSSScore:   9.8,
		Aliases:     []string{"CVE-2023-12345"},
		References:  []string{"https://example.com/advisory"},
		Source:      "test",
	}

	assert.Equal(t, "TEST-001", vuln.ID)
	assert.Equal(t, "Test Vulnerability", vuln.Title)
	assert.Equal(t, types.SeverityHigh, vuln.Severity)
	assert.Equal(t, "high", vuln.Severity.String())
	assert.Contains(t, vuln.Aliases, "CVE-2023-12345")
	assert.Contains(t, vuln.References, "https://example.com/advisory")

	// Test AffectedPackage struct
	affectedPkg := types.AffectedPackage{
		Name:         "test-package",
		Ecosystem:    "npm",
		Versions:     []string{"1.0.0", "1.0.1"},
		VersionRange: ">=1.0.0 <1.0.2",
		PURL:         "pkg:npm/test-package@1.0.0",
	}

	assert.Equal(t, "test-package", affectedPkg.Name)
	assert.Equal(t, "npm", affectedPkg.Ecosystem)
	assert.Contains(t, affectedPkg.Versions, "1.0.0")
	assert.Equal(t, ">=1.0.0 <1.0.2", affectedPkg.VersionRange)
}

// TestManagerConfiguration tests manager configuration
func TestManagerConfiguration(t *testing.T) {
	config := &ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
				Timeout: 10 * time.Second,
			},
			{
				Type:    "github",
				Enabled: false, // Disabled
				Timeout: 15 * time.Second,
			},
		},
		ParallelQueries:  true,
		Timeout:          30 * time.Second,
		MergeResults:     true,
		DeduplicateByID:  true,
		Priority:         []string{"osv", "github"},
	}

	manager := NewManager(config)
	require.NotNil(t, manager)

	// Only OSV should be enabled
	assert.Equal(t, 1, manager.GetDatabaseCount())
	dbNames := manager.GetDatabaseNames()
	assert.Contains(t, dbNames, "osv")
	assert.NotContains(t, dbNames, "github")

	// Test configuration update
	newConfig := &ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
			},
			{
				Type:    "github",
				Enabled: true, // Now enabled
			},
		},
		ParallelQueries: false,
		MergeResults:    false,
	}

	manager.UpdateConfiguration(newConfig)
	
	// Both databases should now be enabled
	assert.Equal(t, 2, manager.GetDatabaseCount())
	dbNames = manager.GetDatabaseNames()
	assert.Contains(t, dbNames, "osv")
	assert.Contains(t, dbNames, "github")
}

// TestDatabaseAddRemove tests dynamic database management
func TestDatabaseAddRemove(t *testing.T) {
	config := &ManagerConfig{
		Databases:       []types.VulnerabilityDatabaseConfig{},
		ParallelQueries: true,
		MergeResults:    true,
	}

	manager := NewManager(config)
	require.NotNil(t, manager)

	// Initially no databases
	assert.Equal(t, 0, manager.GetDatabaseCount())

	// Add OSV database
	osvDB := NewOSVDatabase()
	manager.AddDatabase("osv", osvDB)
	assert.Equal(t, 1, manager.GetDatabaseCount())
	assert.Contains(t, manager.GetDatabaseNames(), "osv")

	// Add GitHub database
	githubDB := NewGitHubAdvisoryDatabase("")
	manager.AddDatabase("github", githubDB)
	assert.Equal(t, 2, manager.GetDatabaseCount())
	assert.Contains(t, manager.GetDatabaseNames(), "github")

	// Remove OSV database
	manager.RemoveDatabase("osv")
	assert.Equal(t, 1, manager.GetDatabaseCount())
	assert.NotContains(t, manager.GetDatabaseNames(), "osv")
	assert.Contains(t, manager.GetDatabaseNames(), "github")

	// Remove GitHub database
	manager.RemoveDatabase("github")
	assert.Equal(t, 0, manager.GetDatabaseCount())
}

// BenchmarkVulnerabilityCheck benchmarks vulnerability checking performance
func BenchmarkVulnerabilityCheck(b *testing.B) {
	if testing.Short() {
		b.Skip("Skipping benchmark in short mode")
	}

	config := &ManagerConfig{
		Databases: []types.VulnerabilityDatabaseConfig{
			{
				Type:    "osv",
				Enabled: true,
				Timeout: 10 * time.Second,
			},
		},
		ParallelQueries: true,
		MergeResults:    true,
	}

	manager := NewManager(config)
	pkg := &types.Package{
		Name:     "lodash",
		Version:  "4.17.20",
		Registry: "npm",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := manager.CheckVulnerabilities(pkg)
		if err != nil {
			b.Fatalf("Vulnerability check failed: %v", err)
		}
	}
}

// TestErrorHandling tests error handling in vulnerability databases
func TestErrorHandling(t *testing.T) {
	config := &ManagerConfig{
		Databases:       []types.VulnerabilityDatabaseConfig{},
		ParallelQueries: true,
		Timeout:         1 * time.Second, // Short timeout
	}

	manager := NewManager(config)

	// Test with no databases configured
	pkg := &types.Package{
		Name:     "test",
		Version:  "1.0.0",
		Registry: "npm",
	}

	_, err := manager.CheckVulnerabilities(pkg)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no vulnerability databases configured")

	// Test GetVulnerabilityByID with no databases
	_, err = manager.GetVulnerabilityByID("TEST-001")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no vulnerability databases configured")

	// Test SearchVulnerabilities with no databases
	_, err = manager.SearchVulnerabilities("test")
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no vulnerability databases configured")
}