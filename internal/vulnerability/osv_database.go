package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/Alivanroy/Typosentinel/pkg/types"
)

// OSVDatabase implements vulnerability database using Google's OSV API
// OSV (Open Source Vulnerabilities) is a comprehensive, open-source vulnerability database
type OSVDatabase struct {
	httpClient *http.Client
	apiURL     string
	cache      map[string][]*types.Vulnerability
}

// NewOSVDatabase creates a new OSV database client
func NewOSVDatabase() *OSVDatabase {
	return &OSVDatabase{
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		apiURL: "https://api.osv.dev/v1",
		cache:  make(map[string][]*types.Vulnerability),
	}
}

// OSVQueryRequest represents a query to the OSV API
type OSVQueryRequest struct {
	Package *OSVPackage `json:"package,omitempty"`
	Version string      `json:"version,omitempty"`
	Commit  string      `json:"commit,omitempty"`
}

// OSVPackage represents a package in OSV format
type OSVPackage struct {
	Name      string `json:"name"`
	Ecosystem string `json:"ecosystem"`
}

// OSVResponse represents the response from OSV API
type OSVResponse struct {
	Vulns []OSVVulnerability `json:"vulns"`
}

// OSVVulnerability represents a vulnerability in OSV format
type OSVVulnerability struct {
	ID               string                 `json:"id"`
	Summary          string                 `json:"summary"`
	Details          string                 `json:"details"`
	Aliases          []string               `json:"aliases"`
	Modified         string                 `json:"modified"`
	Published        string                 `json:"published"`
	Withdrawn        string                 `json:"withdrawn,omitempty"`
	Affected         []OSVAffected          `json:"affected"`
	References       []OSVReference         `json:"references"`
	Severity         []OSVSeverity          `json:"severity"`
	DatabaseSpecific map[string]interface{} `json:"database_specific,omitempty"`
}

// OSVAffected represents affected packages/versions
type OSVAffected struct {
	Package           OSVPackage      `json:"package"`
	Ranges            []OSVRange      `json:"ranges"`
	Versions          []string        `json:"versions,omitempty"`
	EcosystemSpecific map[string]interface{} `json:"ecosystem_specific,omitempty"`
	DatabaseSpecific  map[string]interface{} `json:"database_specific,omitempty"`
}

// OSVRange represents version ranges
type OSVRange struct {
	Type   string     `json:"type"`
	Repo   string     `json:"repo,omitempty"`
	Events []OSVEvent `json:"events"`
}

// OSVEvent represents version events
type OSVEvent struct {
	Introduced string `json:"introduced,omitempty"`
	Fixed      string `json:"fixed,omitempty"`
	LastAffected string `json:"last_affected,omitempty"`
	Limit      string `json:"limit,omitempty"`
}

// OSVReference represents external references
type OSVReference struct {
	Type string `json:"type"`
	URL  string `json:"url"`
}

// OSVSeverity represents severity information
type OSVSeverity struct {
	Type  string `json:"type"`
	Score string `json:"score"`
}

// CheckVulnerabilities checks for vulnerabilities in a package using OSV API
func (db *OSVDatabase) CheckVulnerabilities(pkg *types.Package) ([]*types.Vulnerability, error) {
	// Check cache first
	cacheKey := fmt.Sprintf("%s:%s:%s", pkg.Name, pkg.Version, pkg.Registry)
	if vulns, exists := db.cache[cacheKey]; exists {
		return vulns, nil
	}

	// Map registry to OSV ecosystem
	ecosystem := db.mapRegistryToEcosystem(pkg.Registry)
	if ecosystem == "" {
		return nil, fmt.Errorf("unsupported registry: %s", pkg.Registry)
	}

	// Create query request
	req := OSVQueryRequest{
		Package: &OSVPackage{
			Name:      pkg.Name,
			Ecosystem: ecosystem,
		},
		Version: pkg.Version,
	}

	// Query OSV API
	vulns, err := db.queryOSV(req)
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV database: %w", err)
	}

	// Convert OSV vulnerabilities to internal format
	result := make([]*types.Vulnerability, 0, len(vulns))
	for _, vuln := range vulns {
		converted := db.convertOSVToVulnerability(vuln)
		result = append(result, converted)
	}

	// Cache the results
	db.cache[cacheKey] = result

	return result, nil
}

// GetVulnerabilityByID retrieves a specific vulnerability by ID from OSV
func (db *OSVDatabase) GetVulnerabilityByID(id string) (*types.Vulnerability, error) {
	url := fmt.Sprintf("%s/vulns/%s", db.apiURL, id)
	
	resp, err := db.httpClient.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch OSV data: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var osvVuln OSVVulnerability
	if err := json.Unmarshal(body, &osvVuln); err != nil {
		return nil, fmt.Errorf("failed to parse OSV response: %w", err)
	}

	return db.convertOSVToVulnerability(osvVuln), nil
}

// SearchVulnerabilities searches for vulnerabilities by query
func (db *OSVDatabase) SearchVulnerabilities(query string) ([]*types.Vulnerability, error) {
	// OSV doesn't have a direct search endpoint, so we'll try to parse the query
	// and make targeted requests
	parts := strings.Split(query, ":")
	if len(parts) != 2 {
		return nil, fmt.Errorf("query format should be 'ecosystem:package_name'")
	}

	ecosystem := parts[0]
	packageName := parts[1]

	req := OSVQueryRequest{
		Package: &OSVPackage{
			Name:      packageName,
			Ecosystem: ecosystem,
		},
	}

	vulns, err := db.queryOSV(req)
	if err != nil {
		return nil, err
	}

	result := make([]*types.Vulnerability, 0, len(vulns))
	for _, vuln := range vulns {
		converted := db.convertOSVToVulnerability(vuln)
		result = append(result, converted)
	}

	return result, nil
}

// queryOSV makes a query to the OSV API
func (db *OSVDatabase) queryOSV(req OSVQueryRequest) ([]OSVVulnerability, error) {
	reqBody, err := json.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	url := fmt.Sprintf("%s/query", db.apiURL)
	resp, err := db.httpClient.Post(url, "application/json", strings.NewReader(string(reqBody)))
	if err != nil {
		return nil, fmt.Errorf("failed to query OSV: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	var osvResp OSVResponse
	if err := json.Unmarshal(body, &osvResp); err != nil {
		return nil, fmt.Errorf("failed to parse OSV response: %w", err)
	}

	return osvResp.Vulns, nil
}

// mapRegistryToEcosystem maps package registry to OSV ecosystem
func (db *OSVDatabase) mapRegistryToEcosystem(registry string) string {
	switch strings.ToLower(registry) {
	case "npm":
		return "npm"
	case "pypi":
		return "PyPI"
	case "go":
		return "Go"
	case "maven":
		return "Maven"
	case "nuget":
		return "NuGet"
	case "packagist":
		return "Packagist"
	case "rubygems":
		return "RubyGems"
	case "crates.io":
		return "crates.io"
	default:
		return ""
	}
}

// convertOSVToVulnerability converts OSV vulnerability to internal format
func (db *OSVDatabase) convertOSVToVulnerability(osv OSVVulnerability) *types.Vulnerability {
	vuln := &types.Vulnerability{
		ID:          osv.ID,
		Title:       osv.Summary,
		Description: osv.Details,
		Published:   osv.Published,
		Modified:    osv.Modified,
		Aliases:     osv.Aliases,
		References:  make([]string, 0, len(osv.References)),
		Source:      "osv",
	}

	// Convert references
	for _, ref := range osv.References {
		vuln.References = append(vuln.References, ref.URL)
	}

	// Extract severity information
	for _, severity := range osv.Severity {
		if severity.Type == "CVSS_V3" {
			vuln.CVSS = severity.Score
			vuln.Severity = db.extractSeverityFromCVSS(severity.Score)
			break
		}
	}

	// Extract affected packages and versions
	for _, affected := range osv.Affected {
		vuln.AffectedPackages = append(vuln.AffectedPackages, types.AffectedPackage{
			Name:      affected.Package.Name,
			Ecosystem: affected.Package.Ecosystem,
			Versions:  affected.Versions,
		})
	}

	return vuln
}

// extractSeverityFromCVSS extracts severity level from CVSS score
func (db *OSVDatabase) extractSeverityFromCVSS(cvssVector string) types.Severity {
	// Parse CVSS vector to extract base score
	// This is a simplified implementation - in production, use a proper CVSS parser
	if strings.Contains(cvssVector, "AV:N") && strings.Contains(cvssVector, "AC:L") {
		return types.SeverityHigh
	}
	if strings.Contains(cvssVector, "AV:L") {
		return types.SeverityMedium
	}
	return types.SeverityLow
}

// Update refreshes the vulnerability database cache
func (db *OSVDatabase) Update(ctx context.Context) error {
	// OSV is always up-to-date via API, so we just clear the cache
	db.cache = make(map[string][]*types.Vulnerability)
	return nil
}