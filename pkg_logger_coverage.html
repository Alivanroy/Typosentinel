
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>logger: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Alivanroy/Typosentinel/pkg/logger/debug.go (83.5%)</option>
				
				<option value="file1">github.com/Alivanroy/Typosentinel/pkg/logger/init.go (87.5%)</option>
				
				<option value="file2">github.com/Alivanroy/Typosentinel/pkg/logger/logger.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package logger

import (
        "fmt"
        "runtime"
        "strings"
        "time"
)

// DebugMode represents different debug modes
type DebugMode int

const (
        DebugModeOff DebugMode = iota
        DebugModeBasic
        DebugModeVerbose
        DebugModeTrace
)

// String returns the string representation of debug mode
func (d DebugMode) String() string <span class="cov8" title="1">{
        switch d </span>{
        case DebugModeOff:<span class="cov8" title="1">
                return "off"</span>
        case DebugModeBasic:<span class="cov8" title="1">
                return "basic"</span>
        case DebugModeVerbose:<span class="cov8" title="1">
                return "verbose"</span>
        case DebugModeTrace:<span class="cov8" title="1">
                return "trace"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// ParseDebugMode parses a string into a DebugMode
func ParseDebugMode(mode string) DebugMode <span class="cov8" title="1">{
        switch strings.ToLower(mode) </span>{
        case "off", "false", "0":<span class="cov8" title="1">
                return DebugModeOff</span>
        case "basic", "debug", "1":<span class="cov8" title="1">
                return DebugModeBasic</span>
        case "verbose", "verb", "2":<span class="cov8" title="1">
                return DebugModeVerbose</span>
        case "trace", "3":<span class="cov8" title="1">
                return DebugModeTrace</span>
        default:<span class="cov8" title="1">
                return DebugModeOff</span>
        }
}

// DebugConfig contains debug-specific configuration
type DebugConfig struct {
        Mode           DebugMode
        ShowCaller     bool
        ShowTimestamp  bool
        ShowGoroutine  bool
        ShowMemStats   bool
        IncludeStack   bool
        MaxStackDepth  int
}

// DefaultDebugConfig returns a default debug configuration
func DefaultDebugConfig() *DebugConfig <span class="cov8" title="1">{
        return &amp;DebugConfig{
                Mode:          DebugModeOff,
                ShowCaller:    true,
                ShowTimestamp: true,
                ShowGoroutine: false,
                ShowMemStats:  false,
                IncludeStack:  false,
                MaxStackDepth: 10,
        }
}</span>

// DebugLogger provides enhanced debugging capabilities
type DebugLogger struct {
        logger *Logger
        config *DebugConfig
}

// NewDebugLogger creates a new debug logger
func NewDebugLogger(logger *Logger, config *DebugConfig) *DebugLogger <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultDebugConfig()
        }</span>
        <span class="cov8" title="1">return &amp;DebugLogger{
                logger: logger,
                config: config,
        }</span>
}

// SetDebugMode sets the debug mode
func (dl *DebugLogger) SetDebugMode(mode DebugMode) <span class="cov8" title="1">{
        dl.config.Mode = mode
        
        // Adjust logger level based on debug mode
        switch mode </span>{
        case DebugModeOff:<span class="cov8" title="1">
                dl.logger.SetLevel(INFO)</span>
        case DebugModeBasic:<span class="cov8" title="1">
                dl.logger.SetLevel(DEBUG)</span>
        case DebugModeVerbose:<span class="cov8" title="1">
                dl.logger.SetLevel(VERBOSE)</span>
        case DebugModeTrace:<span class="cov8" title="1">
                dl.logger.SetLevel(TRACE)</span>
        }
}

// IsEnabled checks if debug logging is enabled for the given level
func (dl *DebugLogger) IsEnabled(level LogLevel) bool <span class="cov8" title="1">{
        switch dl.config.Mode </span>{
        case DebugModeOff:<span class="cov8" title="1">
                return false</span>
        case DebugModeBasic:<span class="cov8" title="1">
                return level &gt;= DEBUG</span>
        case DebugModeVerbose:<span class="cov8" title="1">
                return level &gt;= VERBOSE</span>
        case DebugModeTrace:<span class="cov8" title="1">
                return level &gt;= TRACE</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// getCallerInfo returns caller information
func (dl *DebugLogger) getCallerInfo(skip int) map[string]interface{} <span class="cov8" title="1">{
        fields := make(map[string]interface{})
        
        if dl.config.ShowCaller </span><span class="cov8" title="1">{
                if pc, file, line, ok := runtime.Caller(skip + 2); ok </span><span class="cov8" title="1">{
                        funcName := runtime.FuncForPC(pc).Name()
                        // Extract just the function name
                        if idx := strings.LastIndex(funcName, "."); idx != -1 </span><span class="cov8" title="1">{
                                funcName = funcName[idx+1:]
                        }</span>
                        // Extract just the filename
                        <span class="cov8" title="1">if idx := strings.LastIndex(file, "/"); idx != -1 </span><span class="cov8" title="1">{
                                file = file[idx+1:]
                        }</span> else<span class="cov0" title="0"> if idx := strings.LastIndex(file, "\\"); idx != -1 </span><span class="cov0" title="0">{
                                file = file[idx+1:]
                        }</span>
                        <span class="cov8" title="1">fields["caller"] = fmt.Sprintf("%s:%d", file, line)
                        fields["function"] = funcName</span>
                }
        }
        
        <span class="cov8" title="1">if dl.config.ShowGoroutine </span><span class="cov8" title="1">{
                fields["goroutine"] = runtime.NumGoroutine()
        }</span>
        
        <span class="cov8" title="1">if dl.config.ShowTimestamp </span><span class="cov8" title="1">{
                fields["timestamp"] = time.Now().Format(time.RFC3339Nano)
        }</span>
        
        <span class="cov8" title="1">return fields</span>
}

// getStackTrace returns stack trace information
func (dl *DebugLogger) getStackTrace() string <span class="cov8" title="1">{
        if !dl.config.IncludeStack </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        stack := string(buf[:n])
        
        // Limit stack depth if configured
        if dl.config.MaxStackDepth &gt; 0 </span><span class="cov8" title="1">{
                lines := strings.Split(stack, "\n")
                if len(lines) &gt; dl.config.MaxStackDepth*2 </span><span class="cov8" title="1">{
                        lines = lines[:dl.config.MaxStackDepth*2]
                        stack = strings.Join(lines, "\n") + "\n... (truncated)"
                }</span>
        }
        
        <span class="cov8" title="1">return stack</span>
}

// DebugWithContext logs a debug message with enhanced context
func (dl *DebugLogger) DebugWithContext(msg string, extraFields ...map[string]interface{}) <span class="cov8" title="1">{
        if !dl.IsEnabled(DEBUG) </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">fields := dl.getCallerInfo(1)
        if len(extraFields) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range extraFields[0] </span><span class="cov0" title="0">{
                        fields[k] = v
                }</span>
        }
        
        <span class="cov8" title="1">if stack := dl.getStackTrace(); stack != "" </span><span class="cov0" title="0">{
                fields["stack"] = stack
        }</span>
        
        <span class="cov8" title="1">dl.logger.Debug(msg, fields)</span>
}

// VerboseWithContext logs a verbose message with enhanced context
func (dl *DebugLogger) VerboseWithContext(msg string, extraFields ...map[string]interface{}) <span class="cov8" title="1">{
        if !dl.IsEnabled(VERBOSE) </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">fields := dl.getCallerInfo(1)
        if len(extraFields) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range extraFields[0] </span><span class="cov0" title="0">{
                        fields[k] = v
                }</span>
        }
        
        <span class="cov8" title="1">dl.logger.Verbose(msg, fields)</span>
}

// TraceWithContext logs a trace message with enhanced context
func (dl *DebugLogger) TraceWithContext(msg string, extraFields ...map[string]interface{}) <span class="cov8" title="1">{
        if !dl.IsEnabled(TRACE) </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">fields := dl.getCallerInfo(1)
        if len(extraFields) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range extraFields[0] </span><span class="cov0" title="0">{
                        fields[k] = v
                }</span>
        }
        
        <span class="cov8" title="1">if stack := dl.getStackTrace(); stack != "" </span><span class="cov8" title="1">{
                fields["stack"] = stack
        }</span>
        
        <span class="cov8" title="1">dl.logger.Trace(msg, fields)</span>
}

// TraceFunction logs function entry and exit
func (dl *DebugLogger) TraceFunction(funcName string) func() <span class="cov8" title="1">{
        if !dl.IsEnabled(TRACE) </span><span class="cov0" title="0">{
                return func() </span>{<span class="cov0" title="0">}</span>
        }
        
        <span class="cov8" title="1">start := time.Now()
        fields := dl.getCallerInfo(1)
        fields["function"] = funcName
        
        dl.logger.Trace(fmt.Sprintf("Entering function: %s", funcName), fields)
        
        return func() </span><span class="cov8" title="1">{
                fields["duration"] = time.Since(start).String()
                dl.logger.Trace(fmt.Sprintf("Exiting function: %s", funcName), fields)
        }</span>
}

// Global debug logger instance
var globalDebugLogger *DebugLogger

// getOrCreateGlobalDebugLogger returns the global debug logger, creating it if necessary
func getOrCreateGlobalDebugLogger() *DebugLogger <span class="cov8" title="1">{
        if globalDebugLogger == nil </span><span class="cov8" title="1">{
                globalDebugLogger = NewDebugLogger(defaultLogger, DefaultDebugConfig())
        }</span>
        <span class="cov8" title="1">return globalDebugLogger</span>
}

// SetGlobalDebugMode sets the debug mode for the global debug logger
func SetGlobalDebugMode(mode DebugMode) <span class="cov8" title="1">{
        getOrCreateGlobalDebugLogger().SetDebugMode(mode)
}</span>

// SetGlobalDebugModeFromString sets the debug mode from string
func SetGlobalDebugModeFromString(mode string) <span class="cov8" title="1">{
        SetGlobalDebugMode(ParseDebugMode(mode))
}</span>

// GetGlobalDebugLogger returns the global debug logger
func GetGlobalDebugLogger() *DebugLogger <span class="cov0" title="0">{
        return getOrCreateGlobalDebugLogger()
}</span>

// Global debug functions
func DebugWithContext(msg string, extraFields ...map[string]interface{}) <span class="cov8" title="1">{
        getOrCreateGlobalDebugLogger().DebugWithContext(msg, extraFields...)
}</span>

func VerboseWithContext(msg string, extraFields ...map[string]interface{}) <span class="cov8" title="1">{
        getOrCreateGlobalDebugLogger().VerboseWithContext(msg, extraFields...)
}</span>

func TraceWithContext(msg string, extraFields ...map[string]interface{}) <span class="cov8" title="1">{
        getOrCreateGlobalDebugLogger().TraceWithContext(msg, extraFields...)
}</span>

func TraceFunction(funcName string) func() <span class="cov0" title="0">{
        return getOrCreateGlobalDebugLogger().TraceFunction(funcName)
}</span>

// IsDebugEnabled checks if debug logging is enabled
func IsDebugEnabled() bool <span class="cov8" title="1">{
        return getOrCreateGlobalDebugLogger().IsEnabled(DEBUG)
}</span>

// IsVerboseEnabled checks if verbose logging is enabled
func IsVerboseEnabled() bool <span class="cov8" title="1">{
        return getOrCreateGlobalDebugLogger().IsEnabled(VERBOSE)
}</span>

// IsTraceEnabled checks if trace logging is enabled
func IsTraceEnabled() bool <span class="cov8" title="1">{
        return getOrCreateGlobalDebugLogger().IsEnabled(TRACE)
}</pre>
		
		<pre class="file" id="file1" style="display: none">package logger

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/natefinch/lumberjack.v2"
)

// InitFromConfig initializes the global logger from configuration
func InitFromConfig(config LoggerConfig) error <span class="cov8" title="1">{
        // Parse log level
        level := ParseLogLevel(config.Level)
        // No error handling needed as ParseLogLevel doesn't return an error

        // Determine output writer
        var output io.Writer
        switch strings.ToLower(config.Output) </span>{
        case "stdout", "":<span class="cov8" title="1">
                output = os.Stdout</span>
        case "stderr":<span class="cov0" title="0">
                output = os.Stderr</span>
        default:<span class="cov8" title="1">
                // File output
                if config.Rotation.Enabled </span><span class="cov8" title="1">{
                        // Use lumberjack for log rotation
                        output = &amp;lumberjack.Logger{
                                Filename:   config.Output,
                                MaxSize:    config.Rotation.MaxSize,
                                MaxBackups: config.Rotation.MaxBackups,
                                MaxAge:     config.Rotation.MaxAge,
                                Compress:   config.Rotation.Compress,
                        }
                }</span> else<span class="cov8" title="1"> {
                        // Create directory if it doesn't exist
                        dir := filepath.Dir(config.Output)
                        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create log directory: %w", err)
                        }</span>

                        // Open file for writing
                        <span class="cov8" title="1">file, err := os.OpenFile(config.Output, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to open log file: %w", err)
                        }</span>
                        <span class="cov8" title="1">output = file</span>
                }
        }

        // Create logger configuration
        <span class="cov8" title="1">loggerConfig := Config{
                Level:     level,
                Format:    config.Format,
                Output:    output,
                Timestamp: config.Timestamp,
                Caller:    config.Caller,
                Prefix:    config.Prefix,
        }

        // Create new logger and set as global
        newLogger := NewWithConfig(&amp;loggerConfig)
        defaultLogger = newLogger

        return nil</span>
}

// LoggerConfig represents the configuration structure for logger initialization
type LoggerConfig struct {
        Level     string
        Format    string
        Output    string
        Timestamp bool
        Caller    bool
        Prefix    string
        Rotation  RotationConfig
}

// RotationConfig represents log rotation configuration
type RotationConfig struct {
        Enabled    bool
        MaxSize    int
        MaxBackups int
        MaxAge     int
        Compress   bool
}

// InitDefault initializes the logger with default settings
func InitDefault() <span class="cov8" title="1">{
        defaultLogger = New()
}</span>

// InitWithLevel initializes the logger with a specific log level
func InitWithLevel(level LogLevel) <span class="cov8" title="1">{
        config := DefaultConfig()
        config.Level = level
        defaultLogger = NewWithConfig(config)
}</span>

// InitForTesting initializes a logger suitable for testing
func InitForTesting() <span class="cov8" title="1">{
        config := Config{
                Level:     DEBUG,
                Format:    "text",
                Output:    os.Stdout,
                Timestamp: false,
                Caller:    true,
                Prefix:    "[TEST]",
        }
        defaultLogger = NewWithConfig(&amp;config)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package logger

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "strings"
        "time"
)

// LogLevel represents the logging level
type LogLevel int

const (
        TRACE LogLevel = iota
        DEBUG
        VERBOSE
        INFO
        WARN
        ERROR
        FATAL
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case TRACE:<span class="cov8" title="1">
                return "TRACE"</span>
        case DEBUG:<span class="cov8" title="1">
                return "DEBUG"</span>
        case VERBOSE:<span class="cov8" title="1">
                return "VERBOSE"</span>
        case INFO:<span class="cov8" title="1">
                return "INFO"</span>
        case WARN:<span class="cov8" title="1">
                return "WARN"</span>
        case ERROR:<span class="cov8" title="1">
                return "ERROR"</span>
        case FATAL:<span class="cov8" title="1">
                return "FATAL"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// ParseLogLevel parses a string into a LogLevel
func ParseLogLevel(level string) LogLevel <span class="cov8" title="1">{
        switch strings.ToUpper(level) </span>{
        case "TRACE":<span class="cov8" title="1">
                return TRACE</span>
        case "DEBUG":<span class="cov8" title="1">
                return DEBUG</span>
        case "VERBOSE", "VERB":<span class="cov8" title="1">
                return VERBOSE</span>
        case "INFO":<span class="cov8" title="1">
                return INFO</span>
        case "WARN", "WARNING":<span class="cov8" title="1">
                return WARN</span>
        case "ERROR":<span class="cov8" title="1">
                return ERROR</span>
        case "FATAL":<span class="cov8" title="1">
                return FATAL</span>
        default:<span class="cov8" title="1">
                return INFO</span>
        }
}

// Config represents logger configuration
type Config struct {
        Level      LogLevel
        Format     string // "text" or "json"
        Output     io.Writer
        Timestamp  bool
        Caller     bool
        Prefix     string
}

// DefaultConfig returns a default logger configuration
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Level:     INFO,
                Format:    "text",
                Output:    os.Stdout,
                Timestamp: true,
                Caller:    true,
                Prefix:    "[TYPOSENTINEL]",
        }
}</span>

// Logger provides a configurable logging interface
type Logger struct {
        config *Config
        logger *log.Logger
}

// New creates a new logger instance with default configuration
func New() *Logger <span class="cov8" title="1">{
        return NewWithConfig(DefaultConfig())
}</span>

// NewWithConfig creates a new logger instance with custom configuration
func NewWithConfig(config *Config) *Logger <span class="cov8" title="1">{
        flags := 0
        if config.Timestamp </span><span class="cov8" title="1">{
                flags |= log.LstdFlags
        }</span>
        <span class="cov8" title="1">if config.Caller </span><span class="cov8" title="1">{
                flags |= log.Lshortfile
        }</span>

        <span class="cov8" title="1">return &amp;Logger{
                config: config,
                logger: log.New(config.Output, config.Prefix+" ", flags),
        }</span>
}

// SetLevel sets the logging level
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.config.Level = level
}</span>

// SetFormat sets the logging format ("text" or "json")
func (l *Logger) SetFormat(format string) <span class="cov8" title="1">{
        l.config.Format = format
}</span>

// logEntry represents a structured log entry
type logEntry struct {
        Timestamp string                 `json:"timestamp"`
        Level     string                 `json:"level"`
        Message   string                 `json:"message"`
        Caller    string                 `json:"caller,omitempty"`
        Fields    map[string]interface{} `json:"fields,omitempty"`
}

// log writes a log message if the level is enabled
func (l *Logger) log(level LogLevel, msg string, fields map[string]interface{}) <span class="cov8" title="1">{
        if level &lt; l.config.Level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if l.config.Format == "json" </span><span class="cov8" title="1">{
                entry := logEntry{
                        Timestamp: time.Now().Format(time.RFC3339),
                        Level:     level.String(),
                        Message:   msg,
                        Fields:    fields,
                }

                if l.config.Caller </span><span class="cov8" title="1">{
                        // Simple caller info - in production, you might want to use runtime.Caller
                        entry.Caller = "caller_info"
                }</span>

                <span class="cov8" title="1">jsonData, _ := json.Marshal(entry)
                l.logger.Print(string(jsonData))</span>
        } else<span class="cov8" title="1"> {
                // Text format
                prefix := fmt.Sprintf("[%s]", level.String())
                if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                        fieldStr := ""
                        for k, v := range fields </span><span class="cov8" title="1">{
                                fieldStr += fmt.Sprintf(" %s=%v", k, v)
                        }</span>
                        <span class="cov8" title="1">msg += fieldStr</span>
                }
                <span class="cov8" title="1">l.logger.Print(prefix, " ", msg)</span>
        }
}

// Info logs an info message
func (l *Logger) Info(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                f = fields[0]
        }</span>
        <span class="cov8" title="1">l.log(INFO, msg, f)</span>
}

// Error logs an error message
func (l *Logger) Error(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                f = fields[0]
        }</span>
        <span class="cov8" title="1">l.log(ERROR, msg, f)</span>
}

// Debug logs a debug message
func (l *Logger) Debug(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                f = fields[0]
        }</span>
        <span class="cov8" title="1">l.log(DEBUG, msg, f)</span>
}

// Warn logs a warning message
func (l *Logger) Warn(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                f = fields[0]
        }</span>
        <span class="cov8" title="1">l.log(WARN, msg, f)</span>
}

// Trace logs a trace message
func (l *Logger) Trace(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                f = fields[0]
        }</span>
        <span class="cov8" title="1">l.log(TRACE, msg, f)</span>
}

// Verbose logs a verbose message
func (l *Logger) Verbose(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                f = fields[0]
        }</span>
        <span class="cov8" title="1">l.log(VERBOSE, msg, f)</span>
}

// Fatal logs a fatal message and exits
func (l *Logger) Fatal(msg string, fields ...map[string]interface{}) <span class="cov0" title="0">{
        var f map[string]interface{}
        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                f = fields[0]
        }</span>
        <span class="cov0" title="0">l.log(FATAL, msg, f)
        os.Exit(1)</span>
}

// Infof logs a formatted info message
func (l *Logger) Infof(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        l.log(INFO, msg, nil)
}</span>

// Errorf logs a formatted error message
func (l *Logger) Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        l.log(ERROR, msg, nil)
}</span>

// Debugf logs a formatted debug message
func (l *Logger) Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        l.log(DEBUG, msg, nil)
}</span>

// Warnf logs a formatted warning message
func (l *Logger) Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        l.log(WARN, msg, nil)
}</span>

// Tracef logs a formatted trace message
func (l *Logger) Tracef(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        l.log(TRACE, msg, nil)
}</span>

// Verbosef logs a formatted verbose message
func (l *Logger) Verbosef(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        l.log(VERBOSE, msg, nil)
}</span>

// Fatalf logs a formatted fatal message and exits
func (l *Logger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, v...)
        l.log(FATAL, msg, nil)
        os.Exit(1)
}</span>

// WithFields creates a logger with predefined fields
func (l *Logger) WithFields(fields map[string]interface{}) *FieldLogger <span class="cov8" title="1">{
        return &amp;FieldLogger{
                logger: l,
                fields: fields,
        }
}</span>

// FieldLogger wraps Logger with predefined fields
type FieldLogger struct {
        logger *Logger
        fields map[string]interface{}
}

// Info logs an info message with predefined fields
func (fl *FieldLogger) Info(msg string) <span class="cov8" title="1">{
        fl.logger.log(INFO, msg, fl.fields)
}</span>

// Error logs an error message with predefined fields
func (fl *FieldLogger) Error(msg string) <span class="cov8" title="1">{
        fl.logger.log(ERROR, msg, fl.fields)
}</span>

// Debug logs a debug message with predefined fields
func (fl *FieldLogger) Debug(msg string) <span class="cov8" title="1">{
        fl.logger.log(DEBUG, msg, fl.fields)
}</span>

// Warn logs a warning message with predefined fields
func (fl *FieldLogger) Warn(msg string) <span class="cov8" title="1">{
        fl.logger.log(WARN, msg, fl.fields)
}</span>

// Trace logs a trace message with predefined fields
func (fl *FieldLogger) Trace(msg string) <span class="cov8" title="1">{
        fl.logger.log(TRACE, msg, fl.fields)
}</span>

// Verbose logs a verbose message with predefined fields
func (fl *FieldLogger) Verbose(msg string) <span class="cov8" title="1">{
        fl.logger.log(VERBOSE, msg, fl.fields)
}</span>

// Fatal logs a fatal message with predefined fields and exits
func (fl *FieldLogger) Fatal(msg string) <span class="cov0" title="0">{
        fl.logger.log(FATAL, msg, fl.fields)
        os.Exit(1)
}</span>

// Infof logs a formatted info message with predefined fields
func (fl *FieldLogger) Infof(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(INFO, msg, fl.fields)
}</span>

// Errorf logs a formatted error message with predefined fields
func (fl *FieldLogger) Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(ERROR, msg, fl.fields)
}</span>

// Debugf logs a formatted debug message with predefined fields
func (fl *FieldLogger) Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(DEBUG, msg, fl.fields)
}</span>

// Warnf logs a formatted warning message with predefined fields
func (fl *FieldLogger) Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(WARN, msg, fl.fields)
}</span>

// Tracef logs a formatted trace message with predefined fields
func (fl *FieldLogger) Tracef(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(TRACE, msg, fl.fields)
}</span>

// Verbosef logs a formatted verbose message with predefined fields
func (fl *FieldLogger) Verbosef(format string, v ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(VERBOSE, msg, fl.fields)
}</span>

// Fatalf logs a formatted fatal message with predefined fields and exits
func (fl *FieldLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, v...)
        fl.logger.log(FATAL, msg, fl.fields)
        os.Exit(1)
}</span>

// Global logger instance
var defaultLogger = New()

// Global logging functions
func Info(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        defaultLogger.Info(msg, fields...)
}</span>

func Error(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        defaultLogger.Error(msg, fields...)
}</span>

func Debug(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        defaultLogger.Debug(msg, fields...)
}</span>

func Warn(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        defaultLogger.Warn(msg, fields...)
}</span>

func Infof(format string, v ...interface{}) <span class="cov8" title="1">{
        defaultLogger.Infof(format, v...)
}</span>

func Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        defaultLogger.Errorf(format, v...)
}</span>

func Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        defaultLogger.Debugf(format, v...)
}</span>

func Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        defaultLogger.Warnf(format, v...)
}</span>

func Trace(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        defaultLogger.Trace(msg, fields...)
}</span>

func Verbose(msg string, fields ...map[string]interface{}) <span class="cov8" title="1">{
        defaultLogger.Verbose(msg, fields...)
}</span>

func Fatal(msg string, fields ...map[string]interface{}) <span class="cov0" title="0">{
        defaultLogger.Fatal(msg, fields...)
}</span>

func Tracef(format string, v ...interface{}) <span class="cov8" title="1">{
        defaultLogger.Tracef(format, v...)
}</span>

func Verbosef(format string, v ...interface{}) <span class="cov8" title="1">{
        defaultLogger.Verbosef(format, v...)
}</span>

func Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Fatalf(format, v...)
}</span>

// SetGlobalLevel sets the log level for the global logger
func SetGlobalLevel(level LogLevel) <span class="cov8" title="1">{
        defaultLogger.SetLevel(level)
}</span>

// SetGlobalFormat sets the format for the global logger
func SetGlobalFormat(format string) <span class="cov8" title="1">{
        defaultLogger.SetFormat(format)
}</span>

// GetGlobalLogger returns the global logger instance
func GetGlobalLogger() *Logger <span class="cov8" title="1">{
        return defaultLogger
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
