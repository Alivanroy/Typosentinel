#!/usr/bin/env python3
"""
Enhanced Python Malware Scanner
Advanced malware detection specifically for Python packages with enhanced pattern recognition
"""

import json
import sys
import os
import re
import ast
import tempfile
import shutil
import requests
import tarfile
import zipfile
from pathlib import Path
from typing import Dict, List, Any, Tuple
import hashlib
import base64

class EnhancedPythonMalwareScanner:
    def __init__(self):
        self.suspicious_patterns = {
            'obfuscation': [
                r'exec\s*\(\s*["\'].*["\']',  # exec with string
                r'eval\s*\(\s*["\'].*["\']',  # eval with string
                r'compile\s*\(\s*["\'].*["\']',  # compile with string
                r'__import__\s*\(\s*["\'].*["\']',  # dynamic imports
                r'getattr\s*\(\s*.*,\s*["\'].*["\']',  # dynamic attribute access
                r'setattr\s*\(\s*.*,\s*["\'].*["\']',  # dynamic attribute setting
                r'chr\s*\(\s*\d+\s*\)',  # character encoding
                r'ord\s*\(\s*["\'].*["\']',  # character decoding
                r'base64\.b64decode',  # base64 decoding
                r'codecs\.decode',  # codec decoding
                r'bytes\.fromhex',  # hex decoding
                r'\\x[0-9a-fA-F]{2}',  # hex escape sequences
                r'\\[0-7]{3}',  # octal escape sequences
            ],
            'network_activity': [
                r'urllib\.request\.urlopen',
                r'urllib\.request\.Request',
                r'requests\.get',
                r'requests\.post',
                r'requests\.put',
                r'requests\.delete',
                r'socket\.socket',
                r'socket\.connect',
                r'ftplib\.FTP',
                r'smtplib\.SMTP',
                r'http\.client\.HTTPConnection',
                r'urllib\.parse\.urlencode',
                r'json\.loads.*requests',
            ],
            'file_operations': [
                r'open\s*\(\s*["\'].*["\'],\s*["\']w',  # file writing
                r'shutil\.copy',
                r'shutil\.move',
                r'shutil\.rmtree',
                r'os\.remove',
                r'os\.unlink',
                r'os\.rmdir',
                r'os\.makedirs',
                r'pathlib\.Path.*\.write_text',
                r'pathlib\.Path.*\.write_bytes',
            ],
            'system_access': [
                r'os\.system',
                r'subprocess\.call',
                r'subprocess\.run',
                r'subprocess\.Popen',
                r'os\.popen',
                r'os\.execv',
                r'os\.spawn',
                r'commands\.getoutput',
                r'platform\.system',
                r'platform\.machine',
                r'getpass\.getuser',
                r'os\.environ',
                r'sys\.argv',
            ],
            'crypto_mining': [
                r'hashlib\.sha256',
                r'hashlib\.md5',
                r'scrypt',
                r'mining',
                r'blockchain',
                r'cryptocurrency',
                r'bitcoin',
                r'ethereum',
                r'monero',
                r'stratum',
                r'pool\..*\.com',
            ],
            'credential_theft': [
                r'password',
                r'passwd',
                r'credential',
                r'token',
                r'api_key',
                r'secret',
                r'keyring',
                r'keychain',
                r'wallet',
                r'private_key',
                r'ssh_key',
                r'\.ssh',
                r'\.aws',
                r'\.docker',
            ],
            'data_exfiltration': [
                r'zipfile\.ZipFile',
                r'tarfile\.open',
                r'pickle\.dumps',
                r'pickle\.loads',
                r'json\.dumps.*requests',
                r'base64\.b64encode',
                r'urllib\.parse\.quote',
                r'gzip\.compress',
                r'zlib\.compress',
            ]
        }
        
        self.high_risk_functions = [
            'exec', 'eval', 'compile', '__import__',
            'os.system', 'subprocess.call', 'subprocess.run',
            'pickle.loads', 'marshal.loads'
        ]
        
        self.suspicious_imports = [
            'ctypes', 'marshal', 'types', 'imp',
            'importlib', 'pkgutil', 'runpy'
        ]

    def download_pypi_package(self, package_name: str, temp_dir: str) -> Tuple[bool, str]:
        """Download a package from PyPI"""
        try:
            # Get package info from PyPI API
            response = requests.get(f"https://pypi.org/pypi/{package_name}/json", timeout=30)
            response.raise_for_status()
            
            package_info = response.json()
            
            # Get the latest version
            latest_version = package_info['info']['version']
            releases = package_info['releases'][latest_version]
            
            # Find source distribution
            source_dist = None
            for release in releases:
                if release['packagetype'] == 'sdist':
                    source_dist = release
                    break
            
            if not source_dist:
                # Fallback to wheel if no source dist
                for release in releases:
                    if release['packagetype'] == 'bdist_wheel':
                        source_dist = release
                        break
            
            if not source_dist:
                return False, "No downloadable distribution found"
            
            # Download the package
            download_url = source_dist['url']
            filename = source_dist['filename']
            
            print(f"â¬‡ï¸  Downloading: {filename}")
            
            download_response = requests.get(download_url, timeout=60)
            download_response.raise_for_status()
            
            file_path = os.path.join(temp_dir, filename)
            with open(file_path, 'wb') as f:
                f.write(download_response.content)
            
            print(f"âœ… Downloaded: {file_path}")
            return True, file_path
            
        except Exception as e:
            return False, str(e)

    def extract_package(self, file_path: str, extract_dir: str) -> bool:
        """Extract a package archive"""
        try:
            print(f"ğŸ“‚ Extracting package: {os.path.basename(file_path)}")
            
            if file_path.endswith('.tar.gz') or file_path.endswith('.tgz'):
                with tarfile.open(file_path, 'r:gz') as tar:
                    tar.extractall(extract_dir)
            elif file_path.endswith('.zip') or file_path.endswith('.whl'):
                with zipfile.ZipFile(file_path, 'r') as zip_file:
                    zip_file.extractall(extract_dir)
            else:
                return False
            
            print(f"âœ… Extracted to: {extract_dir}")
            return True
            
        except Exception as e:
            print(f"âŒ Extraction failed: {e}")
            return False

    def analyze_python_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Analyze a Python file for malicious patterns"""
        findings = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Check for suspicious patterns
            for category, patterns in self.suspicious_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                    for match in matches:
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Determine severity
                        severity = self.determine_severity(category, match.group())
                        
                        findings.append({
                            'file': file_path,
                            'category': category,
                            'pattern': pattern,
                            'match': match.group(),
                            'line': line_num,
                            'severity': severity
                        })
            
            # AST analysis for more sophisticated detection
            try:
                tree = ast.parse(content)
                ast_findings = self.analyze_ast(tree, file_path)
                findings.extend(ast_findings)
            except SyntaxError:
                # File might be obfuscated or not valid Python
                findings.append({
                    'file': file_path,
                    'category': 'syntax_error',
                    'pattern': 'invalid_python_syntax',
                    'match': 'Syntax error in Python file',
                    'line': 0,
                    'severity': 'MEDIUM'
                })
            
        except Exception as e:
            findings.append({
                'file': file_path,
                'category': 'analysis_error',
                'pattern': 'file_read_error',
                'match': str(e),
                'line': 0,
                'severity': 'LOW'
            })
        
        return findings

    def analyze_ast(self, tree: ast.AST, file_path: str) -> List[Dict[str, Any]]:
        """Analyze AST for suspicious patterns"""
        findings = []
        
        class SuspiciousVisitor(ast.NodeVisitor):
            def __init__(self):
                self.findings = []
            
            def visit_Call(self, node):
                # Check for dangerous function calls
                if isinstance(node.func, ast.Name):
                    if node.func.id in ['exec', 'eval', 'compile']:
                        self.findings.append({
                            'file': file_path,
                            'category': 'dangerous_function',
                            'pattern': f'{node.func.id}_call',
                            'match': f'{node.func.id}() call detected',
                            'line': node.lineno,
                            'severity': 'CRITICAL'
                        })
                
                # Check for subprocess calls
                if isinstance(node.func, ast.Attribute):
                    if (isinstance(node.func.value, ast.Name) and 
                        node.func.value.id == 'subprocess' and
                        node.func.attr in ['call', 'run', 'Popen']):
                        self.findings.append({
                            'file': file_path,
                            'category': 'subprocess_call',
                            'pattern': f'subprocess.{node.func.attr}',
                            'match': f'subprocess.{node.func.attr}() call',
                            'line': node.lineno,
                            'severity': 'HIGH'
                        })
                
                self.generic_visit(node)
            
            def visit_Import(self, node):
                # Check for suspicious imports
                for alias in node.names:
                    if alias.name in self.suspicious_imports:
                        self.findings.append({
                            'file': file_path,
                            'category': 'suspicious_import',
                            'pattern': f'import_{alias.name}',
                            'match': f'import {alias.name}',
                            'line': node.lineno,
                            'severity': 'MEDIUM'
                        })
                self.generic_visit(node)
            
            def visit_ImportFrom(self, node):
                # Check for suspicious from imports
                if node.module in self.suspicious_imports:
                    for alias in node.names:
                        self.findings.append({
                            'file': file_path,
                            'category': 'suspicious_import',
                            'pattern': f'from_{node.module}_import_{alias.name}',
                            'match': f'from {node.module} import {alias.name}',
                            'line': node.lineno,
                            'severity': 'MEDIUM'
                        })
                self.generic_visit(node)
        
        visitor = SuspiciousVisitor()
        visitor.visit(tree)
        return visitor.findings

    def determine_severity(self, category: str, match: str) -> str:
        """Determine the severity of a finding"""
        critical_patterns = ['exec', 'eval', 'compile', 'os.system', 'subprocess']
        high_patterns = ['base64.b64decode', 'pickle.loads', 'marshal.loads']
        
        if any(pattern in match.lower() for pattern in critical_patterns):
            return 'CRITICAL'
        elif any(pattern in match.lower() for pattern in high_patterns):
            return 'HIGH'
        elif category in ['obfuscation', 'system_access']:
            return 'HIGH'
        elif category in ['network_activity', 'credential_theft']:
            return 'MEDIUM'
        else:
            return 'LOW'

    def analyze_package(self, package_name: str) -> Dict[str, Any]:
        """Analyze a Python package for malware"""
        print(f"ğŸš€ Starting enhanced malware analysis for: {package_name}")
        
        with tempfile.TemporaryDirectory() as temp_dir:
            # Download package
            success, result = self.download_pypi_package(package_name, temp_dir)
            if not success:
                return {
                    'package_name': package_name,
                    'success': False,
                    'error': result,
                    'findings': []
                }
            
            file_path = result
            
            # Extract package
            extract_dir = os.path.join(temp_dir, 'extracted')
            os.makedirs(extract_dir)
            
            if not self.extract_package(file_path, extract_dir):
                return {
                    'package_name': package_name,
                    'success': False,
                    'error': 'Failed to extract package',
                    'findings': []
                }
            
            # Analyze all Python files
            all_findings = []
            python_files = []
            
            for root, dirs, files in os.walk(extract_dir):
                for file in files:
                    if file.endswith('.py'):
                        file_path = os.path.join(root, file)
                        python_files.append(file_path)
                        findings = self.analyze_python_file(file_path)
                        all_findings.extend(findings)
            
            print(f"ğŸ“Š Analyzed {len(python_files)} Python files")
            
            # Categorize findings by severity
            critical_count = len([f for f in all_findings if f['severity'] == 'CRITICAL'])
            high_count = len([f for f in all_findings if f['severity'] == 'HIGH'])
            medium_count = len([f for f in all_findings if f['severity'] == 'MEDIUM'])
            low_count = len([f for f in all_findings if f['severity'] == 'LOW'])
            
            return {
                'package_name': package_name,
                'success': True,
                'total_files': len(python_files),
                'total_findings': len(all_findings),
                'critical_findings': critical_count,
                'high_findings': high_count,
                'medium_findings': medium_count,
                'low_findings': low_count,
                'findings': all_findings
            }

def main():
    # High-risk Python packages to analyze
    high_risk_packages = [
        'pandas2',
        'pandas3', 
        'django-dev',
        'flasks',
        'beautifulsoup',
        'py-test'
    ]
    
    print("ğŸ ENHANCED PYTHON MALWARE SCANNER")
    print("=" * 60)
    print(f"ğŸ¯ Analyzing {len(high_risk_packages)} high-risk Python packages")
    print("ğŸ” Advanced pattern detection with AST analysis")
    print("=" * 60)
    
    scanner = EnhancedPythonMalwareScanner()
    results = []
    
    for i, package in enumerate(high_risk_packages, 1):
        print(f"\n[{i}/{len(high_risk_packages)}] ğŸ” ANALYZING: {package}")
        print("-" * 50)
        
        result = scanner.analyze_package(package)
        results.append(result)
        
        if result['success']:
            print(f"âœ… Analysis complete for {package}")
            print(f"   ğŸ“Š Files analyzed: {result['total_files']}")
            print(f"   ğŸš¨ Total findings: {result['total_findings']}")
            print(f"      ğŸ”´ Critical: {result['critical_findings']}")
            print(f"      ğŸŸ  High: {result['high_findings']}")
            print(f"      ğŸŸ¡ Medium: {result['medium_findings']}")
            print(f"      ğŸ”µ Low: {result['low_findings']}")
        else:
            print(f"âŒ Failed to analyze {package}: {result['error']}")
    
    # Save results
    output_dir = Path("enhanced_python_malware_results")
    output_dir.mkdir(exist_ok=True)
    
    results_file = output_dir / "enhanced_malware_analysis.json"
    with open(results_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    # Generate summary
    total_packages = len(results)
    successful_analyses = len([r for r in results if r['success']])
    total_critical = sum(r.get('critical_findings', 0) for r in results if r['success'])
    total_high = sum(r.get('high_findings', 0) for r in results if r['success'])
    
    print(f"\nğŸ¯ ENHANCED PYTHON MALWARE ANALYSIS COMPLETE!")
    print("=" * 60)
    print(f"ğŸ“ Results saved to: {output_dir}")
    print(f"ğŸ“Š Packages analyzed: {successful_analyses}/{total_packages}")
    print(f"ğŸš¨ Critical findings: {total_critical}")
    print(f"âš ï¸  High-risk findings: {total_high}")
    print(f"ğŸ“‹ Detailed results: {results_file}")

if __name__ == "__main__":
    main()