#!/usr/bin/env python3
"""
Malware Analysis Tool for Package Security Assessment
Analyzes PyPI packages for malicious patterns and suspicious code
"""

import os
import sys
import ast
import base64
import re
import tarfile
import zipfile
import requests
import json
import shutil
import tempfile
import argparse
from urllib.parse import urlparse
from pathlib import Path

class MalwareAnalyzer:
    def __init__(self):
        self.temp_dir = None
        self.findings = []
        
        # Suspicious patterns to detect
        self.patterns = {
            'obfuscated_code': [
                r'exec\s*\(\s*base64\.b64decode',
                r'eval\s*\(\s*base64\.b64decode',
                r'compile\s*\(\s*base64\.b64decode',
                r'__import__\s*\(\s*["\']base64["\']',
                r'exec\s*\(\s*compile\s*\(',
                r'eval\s*\(\s*compile\s*\(',
            ],
            'data_exfiltration': [
                r'discord\.com/api/webhooks',
                r'telegram\.org',
                r'pastebin\.com',
                r'hastebin\.com',
                r'paste\.ee',
                r'requests\.post.*webhook',
                r'urllib.*webhook',
                r'http.*://.*\.ngrok\.io',
            ],
            'crypto_mining': [
                r'stratum\+tcp://',
                r'xmrig',
                r'minergate',
                r'cryptonight',
                r'monero',
                r'mining.*pool',
                r'hashrate',
            ],
            'credential_theft': [
                r'\.aws/credentials',
                r'\.ssh/id_rsa',
                r'\.docker/config\.json',
                r'password.*=.*input',
                r'getpass\.getpass',
                r'keyring\.get_password',
            ],
            'system_access': [
                r'os\.system\s*\(',
                r'subprocess\.call',
                r'subprocess\.run',
                r'subprocess\.Popen',
                r'os\.popen',
                r'commands\.getoutput',
            ],
            'network_activity': [
                r'socket\.socket',
                r'urllib\.request',
                r'requests\.get',
                r'requests\.post',
                r'http\.client',
                r'ftplib\.FTP',
            ]
        }

    def download_package(self, package_name, version=None):
        """Download package from PyPI"""
        try:
            print(f"ğŸ“¦ Downloading package: {package_name}")
            
            # Get package info from PyPI
            if version:
                url = f"https://pypi.org/pypi/{package_name}/{version}/json"
            else:
                url = f"https://pypi.org/pypi/{package_name}/json"
            
            response = requests.get(url)
            response.raise_for_status()
            
            package_info = response.json()
            
            # Find source distribution
            files = package_info['urls']
            source_dist = None
            
            for file_info in files:
                if file_info['packagetype'] == 'sdist':
                    source_dist = file_info
                    break
            
            if not source_dist:
                print(f"âŒ No source distribution found for {package_name}")
                return None
            
            # Download the package
            download_url = source_dist['url']
            filename = source_dist['filename']
            
            print(f"â¬‡ï¸  Downloading: {filename}")
            
            response = requests.get(download_url)
            response.raise_for_status()
            
            # Save to temp directory
            if not self.temp_dir:
                self.temp_dir = tempfile.mkdtemp(prefix='malware_analysis_')
            
            package_path = os.path.join(self.temp_dir, filename)
            with open(package_path, 'wb') as f:
                f.write(response.content)
            
            print(f"âœ… Downloaded: {package_path}")
            return package_path
            
        except Exception as e:
            print(f"âŒ Error downloading {package_name}: {e}")
            return None

    def extract_package(self, package_path):
        """Extract package contents"""
        try:
            extract_dir = os.path.join(self.temp_dir, 'extracted')
            os.makedirs(extract_dir, exist_ok=True)
            
            print(f"ğŸ“‚ Extracting package: {os.path.basename(package_path)}")
            
            if package_path.endswith('.tar.gz') or package_path.endswith('.tgz'):
                with tarfile.open(package_path, 'r:gz') as tar:
                    tar.extractall(extract_dir)
            elif package_path.endswith('.zip'):
                with zipfile.ZipFile(package_path, 'r') as zip_file:
                    zip_file.extractall(extract_dir)
            else:
                print(f"âŒ Unsupported package format: {package_path}")
                return None
            
            print(f"âœ… Extracted to: {extract_dir}")
            return extract_dir
            
        except Exception as e:
            print(f"âŒ Error extracting package: {e}")
            return None

    def analyze_file(self, filepath):
        """Analyze a single file for malicious patterns"""
        file_findings = []
        
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Check each pattern category
            for category, patterns in self.patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                    for match in matches:
                        # Get line number
                        line_num = content[:match.start()].count('\n') + 1
                        
                        file_findings.append({
                            'file': filepath,
                            'category': category,
                            'pattern': pattern,
                            'match': match.group(),
                            'line': line_num,
                            'severity': self.get_severity(category)
                        })
            
            # Additional checks for Python files
            if filepath.endswith('.py'):
                file_findings.extend(self.analyze_python_ast(filepath, content))
                
        except Exception as e:
            print(f"âš ï¸  Error analyzing file {filepath}: {e}")
        
        return file_findings

    def analyze_python_ast(self, filepath, content):
        """Analyze Python AST for suspicious constructs"""
        findings = []
        
        try:
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                # Check for dynamic imports
                if isinstance(node, ast.Call):
                    if (isinstance(node.func, ast.Name) and 
                        node.func.id == '__import__' and 
                        len(node.args) > 0):
                        findings.append({
                            'file': filepath,
                            'category': 'dynamic_import',
                            'pattern': 'AST: __import__ call',
                            'match': f"__import__({ast.unparse(node.args[0]) if hasattr(ast, 'unparse') else 'dynamic'})",
                            'line': node.lineno,
                            'severity': 'MEDIUM'
                        })
                
                # Check for exec/eval calls
                if (isinstance(node, ast.Call) and 
                    isinstance(node.func, ast.Name) and 
                    node.func.id in ['exec', 'eval']):
                    findings.append({
                        'file': filepath,
                        'category': 'code_execution',
                        'pattern': f'AST: {node.func.id} call',
                        'match': f"{node.func.id}(...)",
                        'line': node.lineno,
                        'severity': 'HIGH'
                    })
                        
        except SyntaxError:
            # File might not be valid Python
            pass
        except Exception as e:
            print(f"âš ï¸  AST analysis error for {filepath}: {e}")
        
        return findings

    def get_severity(self, category):
        """Get severity level for a category"""
        severity_map = {
            'obfuscated_code': 'CRITICAL',
            'data_exfiltration': 'CRITICAL',
            'crypto_mining': 'HIGH',
            'credential_theft': 'HIGH',
            'system_access': 'MEDIUM',
            'network_activity': 'LOW'
        }
        return severity_map.get(category, 'MEDIUM')

    def analyze_package_contents(self, extract_dir):
        """Deep analysis of package contents"""
        print(f"ğŸ” Analyzing package contents...")
        
        all_findings = []
        file_count = 0
        
        # Walk through all files
        for root, dirs, files in os.walk(extract_dir):
            for file in files:
                filepath = os.path.join(root, file)
                file_count += 1
                
                # Analyze text files
                if any(filepath.endswith(ext) for ext in ['.py', '.txt', '.md', '.rst', '.cfg', '.ini', '.json', '.yaml', '.yml']):
                    findings = self.analyze_file(filepath)
                    all_findings.extend(findings)
        
        print(f"ğŸ“Š Analyzed {file_count} files")
        return all_findings

    def generate_report(self, package_name, findings):
        """Generate analysis report"""
        print(f"\nğŸ” MALWARE ANALYSIS REPORT: {package_name}")
        print("=" * 60)
        
        if not findings:
            print("âœ… No suspicious patterns detected")
            return
        
        # Group findings by severity
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        category_counts = {}
        
        for finding in findings:
            severity = finding['severity']
            category = finding['category']
            
            severity_counts[severity] += 1
            category_counts[category] = category_counts.get(category, 0) + 1
        
        # Print summary
        print(f"ğŸš¨ TOTAL FINDINGS: {len(findings)}")
        for severity, count in severity_counts.items():
            if count > 0:
                emoji = {'CRITICAL': 'ğŸ”´', 'HIGH': 'ğŸŸ ', 'MEDIUM': 'ğŸŸ¡', 'LOW': 'ğŸŸ¢'}[severity]
                print(f"{emoji} {severity}: {count}")
        
        print(f"\nğŸ“‹ CATEGORIES:")
        for category, count in sorted(category_counts.items()):
            print(f"  â€¢ {category.replace('_', ' ').title()}: {count}")
        
        # Print detailed findings
        print(f"\nğŸ“ DETAILED FINDINGS:")
        for i, finding in enumerate(findings, 1):
            severity_emoji = {'CRITICAL': 'ğŸ”´', 'HIGH': 'ğŸŸ ', 'MEDIUM': 'ğŸŸ¡', 'LOW': 'ğŸŸ¢'}[finding['severity']]
            print(f"\n{i}. {severity_emoji} {finding['severity']} - {finding['category'].replace('_', ' ').title()}")
            print(f"   File: {finding['file']}")
            print(f"   Line: {finding['line']}")
            print(f"   Pattern: {finding['pattern']}")
            print(f"   Match: {finding['match']}")

    def cleanup(self):
        """Clean up temporary files"""
        if self.temp_dir and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
            print(f"ğŸ§¹ Cleaned up temporary files")

    def analyze_package(self, package_name, version=None):
        """Main analysis function"""
        try:
            print(f"ğŸš€ Starting malware analysis for: {package_name}")
            
            # Download package
            package_path = self.download_package(package_name, version)
            if not package_path:
                return False
            
            # Extract package
            extract_dir = self.extract_package(package_path)
            if not extract_dir:
                return False
            
            # Analyze contents
            findings = self.analyze_package_contents(extract_dir)
            
            # Generate report
            self.generate_report(package_name, findings)
            
            return True
            
        except Exception as e:
            print(f"âŒ Analysis failed: {e}")
            return False
        finally:
            self.cleanup()

def main():
    parser = argparse.ArgumentParser(description='Malware Analysis Tool for Python Packages')
    parser.add_argument('packages', nargs='+', help='Package names to analyze')
    parser.add_argument('--version', help='Specific version to analyze')
    parser.add_argument('--output', help='Output file for results (JSON format)')
    
    args = parser.parse_args()
    
    analyzer = MalwareAnalyzer()
    results = {}
    
    for package_name in args.packages:
        print(f"\n{'='*80}")
        success = analyzer.analyze_package(package_name, args.version)
        results[package_name] = {'success': success}
    
    # Save results if output file specified
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nğŸ’¾ Results saved to: {args.output}")

if __name__ == "__main__":
    main()