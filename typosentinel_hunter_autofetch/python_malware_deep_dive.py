#!/usr/bin/env python3
"""
Python Malware Deep Dive Analysis
Performs comprehensive malware analysis on Python packages found during CVE hunting
"""

import json
import sys
import os
from pathlib import Path
from malware_multi_ecosystem import MultiEcosystemMalwareAnalyzer

def main():
    # Real Python packages found during our CVE hunts
    python_candidates = [
        {"name": "pandas2", "ecosystem": "pypi", "risk": 0.97, "priority": "CRITICAL", "source": "typosquatting"},
        {"name": "pandas3", "ecosystem": "pypi", "risk": 0.97, "priority": "CRITICAL", "source": "typosquatting"},
        {"name": "django-dev", "ecosystem": "pypi", "risk": 0.92, "priority": "HIGH", "source": "suspicious_dev"},
        {"name": "beautifulsoup", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "metadata_missing"},
        {"name": "py-test", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "metadata_missing"},
        # Additional suspicious Python packages from aggressive hunt
        {"name": "sckiit-learn", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
        {"name": "f1ask", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
        {"name": "pymongo2", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "version_confusion"},
        {"name": "setupt00ls", "ecosystem": "pypi", "risk": 0.0, "priority": "HIGH", "source": "critical_package"},
        {"name": "tensorflows", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
        {"name": "pytest-lib", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "fake_library"},
        {"name": "scarpy", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
        {"name": "requests-lib", "ecosystem": "pypi", "risk": 0.0, "priority": "HIGH", "source": "fake_library"},
        {"name": "ebautifulsoup4", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
        {"name": "b3autifulsoup4", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
        {"name": "pillow2", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "version_confusion"},
        {"name": "requests-test", "ecosystem": "pypi", "risk": 0.0, "priority": "HIGH", "source": "test_package"},
        {"name": "flasks", "ecosystem": "pypi", "risk": 0.0, "priority": "MEDIUM", "source": "typosquatting"},
    ]
    
    print("üêç PYTHON MALWARE DEEP DIVE ANALYSIS")
    print("=" * 60)
    print(f"üéØ Analyzing {len(python_candidates)} Python packages for malicious content")
    print("üîç Focus: Typosquatting, dependency confusion, and malicious code patterns")
    print("=" * 60)
    
    analyzer = MultiEcosystemMalwareAnalyzer()
    results = []
    
    # Statistics tracking
    critical_malware = []
    high_risk_patterns = []
    typosquatting_threats = []
    dependency_confusion = []
    
    for i, candidate in enumerate(python_candidates, 1):
        print(f"\n[{i}/{len(python_candidates)}] üîç ANALYZING: {candidate['name']}")
        print(f"   üìä Risk Score: {candidate['risk']}")
        print(f"   üö® Priority: {candidate['priority']}")
        print(f"   üéØ Source: {candidate['source']}")
        print("-" * 50)
        
        try:
            # Analyze the package
            success, findings = analyzer.analyze_package(
                candidate['name'], 
                candidate['ecosystem']
            )
            
            if success:
                # Count findings by severity
                critical_count = len([f for f in findings if f['severity'] == 'CRITICAL'])
                high_count = len([f for f in findings if f['severity'] == 'HIGH'])
                medium_count = len([f for f in findings if f['severity'] == 'MEDIUM'])
                low_count = len([f for f in findings if f['severity'] == 'LOW'])
                
                result = {
                    'package_name': candidate['name'],
                    'ecosystem': candidate['ecosystem'],
                    'priority': candidate['priority'],
                    'cve_risk_score': candidate['risk'],
                    'source_type': candidate['source'],
                    'analysis_success': True,
                    'total_findings': len(findings),
                    'critical_findings': critical_count,
                    'high_findings': high_count,
                    'medium_findings': medium_count,
                    'low_findings': low_count,
                    'findings': findings
                }
                
                results.append(result)
                
                # Categorize threats
                if critical_count > 0:
                    critical_malware.append(candidate['name'])
                    print(f"üö® CRITICAL MALWARE DETECTED in {candidate['name']}!")
                elif high_count > 0:
                    high_risk_patterns.append(candidate['name'])
                    print(f"‚ö†Ô∏è  HIGH-RISK patterns found in {candidate['name']}")
                elif medium_count > 0:
                    print(f"‚ö†Ô∏è  Medium-risk patterns found in {candidate['name']}")
                else:
                    print(f"‚úÖ No suspicious patterns found in {candidate['name']}")
                
                # Track by source type
                if candidate['source'] == 'typosquatting' and (critical_count > 0 or high_count > 0):
                    typosquatting_threats.append(candidate['name'])
                elif candidate['source'] in ['version_confusion', 'fake_library'] and (critical_count > 0 or high_count > 0):
                    dependency_confusion.append(candidate['name'])
                
                # Print detailed findings for high-risk packages
                if critical_count > 0 or high_count > 0:
                    print(f"   üìã DETAILED FINDINGS:")
                    for finding in findings:
                        if finding['severity'] in ['CRITICAL', 'HIGH']:
                            print(f"      üî¥ {finding['severity']}: {finding['description']}")
                            print(f"         üìÅ File: {finding.get('file', 'Unknown')}")
                            if 'code_snippet' in finding:
                                print(f"         üíª Code: {finding['code_snippet'][:100]}...")
                
                print(f"   üìä Summary: {len(findings)} total findings")
                print(f"      üî¥ Critical: {critical_count}")
                print(f"      üü† High: {high_count}")
                print(f"      üü° Medium: {medium_count}")
                    
            else:
                print(f"‚ùå Failed to analyze {candidate['name']} (package may not exist)")
                # Still add to results for tracking
                results.append({
                    'package_name': candidate['name'],
                    'ecosystem': candidate['ecosystem'],
                    'priority': candidate['priority'],
                    'cve_risk_score': candidate['risk'],
                    'source_type': candidate['source'],
                    'analysis_success': False,
                    'total_findings': 0,
                    'critical_findings': 0,
                    'high_findings': 0,
                    'medium_findings': 0,
                    'low_findings': 0,
                    'findings': []
                })
                
        except Exception as e:
            print(f"‚ùå Error analyzing {candidate['name']}: {e}")
            # Add failed analysis to results
            results.append({
                'package_name': candidate['name'],
                'ecosystem': candidate['ecosystem'],
                'priority': candidate['priority'],
                'cve_risk_score': candidate['risk'],
                'source_type': candidate['source'],
                'analysis_success': False,
                'error': str(e),
                'total_findings': 0,
                'critical_findings': 0,
                'high_findings': 0,
                'medium_findings': 0,
                'low_findings': 0,
                'findings': []
            })
            continue
    
    # Save results
    output_dir = Path("python_malware_analysis_results")
    output_dir.mkdir(exist_ok=True)
    
    # Save detailed results
    results_file = output_dir / "python_malware_deep_dive.json"
    with open(results_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    # Generate comprehensive report
    generate_python_malware_report(results, critical_malware, high_risk_patterns, 
                                 typosquatting_threats, dependency_confusion, output_dir)
    
    print(f"\nüéØ PYTHON MALWARE DEEP DIVE COMPLETE!")
    print("=" * 60)
    print(f"üìÅ Results saved to: {output_dir}")
    print(f"üìä Analyzed {len(results)} Python packages")
    
    # Print threat summary
    successful_analyses = len([r for r in results if r.get('analysis_success', False)])
    print(f"‚úÖ Successful analyses: {successful_analyses}")
    print(f"üö® Critical malware found: {len(critical_malware)}")
    print(f"‚ö†Ô∏è  High-risk patterns: {len(high_risk_patterns)}")
    print(f"üéØ Typosquatting threats: {len(typosquatting_threats)}")
    print(f"üì¶ Dependency confusion: {len(dependency_confusion)}")
    
    if critical_malware:
        print(f"\nüö® CRITICAL MALWARE DETECTED:")
        for pkg in critical_malware:
            print(f"   - {pkg}")
    
    if high_risk_patterns:
        print(f"\n‚ö†Ô∏è  HIGH-RISK PATTERNS:")
        for pkg in high_risk_patterns:
            print(f"   - {pkg}")

def generate_python_malware_report(results, critical_malware, high_risk_patterns, 
                                 typosquatting_threats, dependency_confusion, output_dir):
    """Generate a comprehensive Python malware analysis report"""
    from datetime import datetime
    
    report_content = f"""# Python Malware Deep Dive Analysis Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary

This report contains the comprehensive malware analysis results for Python packages identified during our CVE hunting operations. The analysis focuses on detecting typosquatting attacks, dependency confusion, and malicious code patterns in the Python ecosystem.

## Analysis Overview

- **Total Python Packages Analyzed**: {len(results)}
- **Critical Malware Detected**: {len(critical_malware)}
- **High-Risk Patterns Found**: {len(high_risk_patterns)}
- **Typosquatting Threats**: {len(typosquatting_threats)}
- **Dependency Confusion Attacks**: {len(dependency_confusion)}

## Threat Categories

### üö® Critical Malware ({len(critical_malware)} packages)
"""
    
    if critical_malware:
        for pkg in critical_malware:
            pkg_result = next((r for r in results if r['package_name'] == pkg), None)
            if pkg_result:
                report_content += f"""
#### {pkg}
- **Risk Score**: {pkg_result['cve_risk_score']}
- **Source**: {pkg_result['source_type']}
- **Critical Findings**: {pkg_result['critical_findings']}
- **High Findings**: {pkg_result['high_findings']}
"""
    else:
        report_content += "\nNo critical malware detected in analyzed packages.\n"
    
    report_content += f"""
### ‚ö†Ô∏è High-Risk Patterns ({len(high_risk_patterns)} packages)
"""
    
    if high_risk_patterns:
        for pkg in high_risk_patterns:
            pkg_result = next((r for r in results if r['package_name'] == pkg), None)
            if pkg_result:
                report_content += f"""
#### {pkg}
- **Risk Score**: {pkg_result['cve_risk_score']}
- **Source**: {pkg_result['source_type']}
- **High Findings**: {pkg_result['high_findings']}
- **Medium Findings**: {pkg_result['medium_findings']}
"""
    else:
        report_content += "\nNo high-risk patterns detected in analyzed packages.\n"
    
    report_content += f"""
## Attack Vector Analysis

### Typosquatting Attacks
Packages that mimic legitimate Python libraries through character substitution, addition, or deletion:
"""
    
    typo_packages = [r for r in results if r['source_type'] == 'typosquatting']
    for pkg in typo_packages:
        report_content += f"- **{pkg['package_name']}** (Risk: {pkg['cve_risk_score']})\n"
    
    report_content += f"""
### Dependency Confusion
Packages that exploit version confusion or fake library names:
"""
    
    dep_packages = [r for r in results if r['source_type'] in ['version_confusion', 'fake_library']]
    for pkg in dep_packages:
        report_content += f"- **{pkg['package_name']}** (Risk: {pkg['cve_risk_score']}, Type: {pkg['source_type']})\n"
    
    report_content += """
## Recommendations

1. **Immediate Actions**:
   - Block all packages identified with critical malware
   - Review and validate any dependencies on high-risk packages
   - Implement package verification in CI/CD pipelines

2. **Long-term Security**:
   - Use dependency pinning with hash verification
   - Implement automated security scanning
   - Monitor for typosquatting variants of critical dependencies
   - Use private package repositories for internal packages

3. **Detection Improvements**:
   - Enhance monitoring for packages with missing metadata
   - Implement real-time scanning of new package uploads
   - Create alerts for packages mimicking popular libraries

## Technical Details

For detailed technical findings, including code snippets and specific malware patterns detected, refer to the JSON results file: `python_malware_deep_dive.json`
"""
    
    # Save the report
    report_file = output_dir / "python_malware_analysis_report.md"
    with open(report_file, 'w') as f:
        f.write(report_content)
    
    print(f"üìã Comprehensive report saved to: {report_file}")

if __name__ == "__main__":
    main()